<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Go 语言实践：编写可维护的程序的建议【译】]]></title>
    <url>%2F2018%2F10%2F27%2FGo-%E8%AF%AD%E8%A8%80%E5%AE%9E%E8%B7%B5%EF%BC%9A%E7%BC%96%E5%86%99%E5%8F%AF%E7%BB%B4%E6%8A%A4%E7%9A%84%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%BB%BA%E8%AE%AE%E3%80%90%E8%AF%91%E3%80%91%2F</url>
    <content type="text"><![CDATA[译者注 本文为 QCon 2018 上海站主题演讲嘉宾、Heptio 资深工程师、著名Go语言专家 David Cheney 关于 Go 语言实践的英文分享。为方便大家阅读，在此由 Austin Luo 翻译为中文。翻译水平有限，如有偏颇之处，烦请联系我更正之。 转载请注明出处，保留本节译者注。 引言 接下来这两场我将给大家一些编写 Go 代码的最佳实践。 今天这是一个研讨会风格的演讲，我会摒弃那些绚丽的 PPT，而是直接使用你们可以直接带走的文档。 TIP: 你可以在这里找到这个演讲最新的在线版本：https://dave.cheney.net/practical-go/presentations/qcon-china.html 指导原则我们要谈论在一个编程语言中的最佳实践，那么我们首先应该明确什么是“最佳”。如果你们听了我昨天那场讲演的话，你一定看到了来自 Go 团队的 Russ Cox 讲的一句话： 软件工程，是当你在编程时增加了工期和其他编程人员之后发生的事。 — Russ Cox Russ 是在阐述软件“编程”和软件“工程”之间的区别，前者是你写的程序，而后者是一个让更多的人长期使用的产品。软件工程师会来来去去地更换，团队也会成长或者萎缩，需求也会发生变化，新的特性也会增加，bug 也会被修复，这就是软件“工程”的本质。 我可能是现场最早的 Go 语言用户，但与其说我的主张来自我的资历，不如说我今天讲的是真实来自于 Go 语言本身的指导原则，那就是： 简单性 可读性 生产率 你可能已经注意到，我并没有提性能或者并发性。实际上有不少的语言执行效率比 Go 还要高，但它们一定没有 Go 这么简单。有些语言也以并发性为最高目标，但它们的可读性和生产率都不好。 性能和并发性都很重要，但它们不如简单性、可读性和生产率那么重要。 简单性为什么我们要力求简单，为什么简单对 Go 语言编程如此重要？ 我们有太多的时候感叹“这段代码我看不懂”，是吧？我们害怕修改一丁点代码，生怕这一点修改就导致其他你不懂的部分出问题，而你又没办法修复它。 这就是复杂性。复杂性把可读的程序变得不可读，复杂性终结了很多软件项目。 简单性是 Go 的最高目标。无论我们写什么程序，我们都应该能一致认为它应当简单。 可读性 可读性对于可维护性至关重要。 — Mark Reinhold, JVM language summit 2018 为什么 Go 代码的可读性如此重要？为什么我们应该力求可读性？ 程序应该是写来被人阅读的，而只是顺带可以被机器执行。— Hal Abelson and Gerald Sussman, Structure and Interpretation of Computer Programs 可阅读性对所有的程序——不仅仅是 Go 程序，都是如此之重要，是因为程序是人写的，并且给其他人阅读的，其次才是被机器所执行。 代码被阅读的次数，远远大于被编写的次数。一段小的代码，在它的整个生命周期，可能被阅读成百上千次。 程序员最重要的技能是有效沟通想法的能力。 — Gastón Jorquera ^1 可读性是弄清楚一个程序是在做什么事的关键。如果你都不知道这个程序在做什么，你如何去维护这个程序？如果一个软件不可用被维护，那就可能被重写，并且这也可能是你公司最后一次在 GO 上面投入了。 如果你仅仅是为自己个人写一个程序，可能这个程序是一次性的，或者使用这个程序的人也只有你一个，那你想怎样写就怎样写。但如果是多人合作贡献的程序，或者因为它解决人们的需求、满足某些特性、运行它的环境会变化，而在一个很长的时间内被很多人使用，那么程序的可维护性则必须成为目标。 编写可维护的程序的第一步，那就是确保代码是可读的。 生产率 设计是一门艺术，要求编写的代码当前可用，并且以后仍能被改动。— Sandi Metz 我想重点阐述的最后一个基本原则是生产率。开发者的生产率是一个复杂的话题，但归结起来就是：为了有效的工作，你因为一些工具、外部代码库而浪费了多少时间。Go 程序员应该感受得到，他们在工作中可以从很多东西中受益了。（Austin Luo：言下之意是，Go 的工具集和基础库完备，很多东西触手可得。） 有一个笑话是说，Go 是在 C++ 程序编译过程中被设计出来的。快速的编译是 Go 语言用以吸引新开发者的关键特性。编译速度仍然是一个不变的战场，很公平地说，其他语言需要几分钟才能编译，而 Go 只需要几秒即可完成。这有助于 Go 开发者有动态语言开发者一样的高效，但又没有那些动态语言本身的可靠性问题。 Go 开发者意识到代码是写来被阅读的，并且把阅读放在编写之上。Go 致力于从工具集、习惯等方面强制要求代码必须编写为一种特定样式，这消除了学习项目特定术语的障碍，同时也可以仅仅从“看起来”不正确即可帮助开发者发现潜在的错误。 Go 开发者不会整日去调试那些莫名其妙的编译错误。他们也不会整日浪费时间在复杂的构建脚本或将代码部署到生产中这事上。更重要的是他们不会花时间在尝试搞懂同事们写的代码是什么意思这事上。 当 Go 语言团队在谈论一个语言必须扩展时，他们谈论的就是生产率。 标识符我们要讨论的第一个议题是标识符。标识符是一个名称的描述词，这个名称可以是一个变量的名称、一个函数的名称、一个方法的名称、一个类型的名称或者一个包的名称等等。 拙劣的名称是拙劣的设计的表征。— Dave Cheney 鉴于 Go 的语法限制，我们为程序中的事物选择的名称对我们程序的可读性产生了过大的影响。良好的可读性是评判代码质量的关键，因此选择好名称对于 Go 代码的可读性至关重要。 选择清晰的名称，而不是简洁的名称 代码要明确这很重要，你在一行中能做的事，应该拆到三行里做。— Ukiah Smith Go 不是专注于将代码精巧优化为一行的那种语言，Go 也不是致力于将代码精炼到最小行数的语言。我们并不追求源码在磁盘上占用的空间更少，也不关心录入代码需要多长时间。 好的名称就如同一个好的笑话，如果你需要去解释它，那它就不搞笑了。— Dave Cheney 这个清晰度的关键就是我们为 Go 程序选择的标识符。让我们来看看一个好的名称应当具备什么吧： 好的名称是简洁的。一个好的名称未必是尽可能短的，但它肯定不会浪费任何无关的东西在上面，好名字具有高信噪比。 好的名称是描述性的。一个好的名称应该描述一个变量或常量的使用，而非其内容。一个好的明明应该描述函数的结果或一个方法的行为，而不是这个函数或方法本身的操作。一个好的名称应该描述一个包的目的，而不是包的内容。名称描述的东西越准确，名称越好。 好的名称是可预测的。您应该能够从名称中推断出它的使用方式，这是选择描述性名称带来的作用，同时也遵循了传统。Go 开发者在谈论惯用语时，即是说的这个。 接下来让我们深入地讨论一下。 标识符长度有时候人们批评 Go 风格推荐短变量名。正如 Rob Pike 所说，“Go 开发者想要的是合适长度的标识符”。^1 Andrew Gerrand 建议通过使用更长的标识符向读者暗示它们具有更高的重要性。 标识符的声明和使用间隔越远，名称的长度就应当越长。 Andrew Gerrand ^2 据此，我们可以归纳一些指导意见： 短变量名称在声明和上次使用之间的距离很短时效果很好。 长变量名证明其不同的合理性：越长的变量名，越需要更多的理由来证明其合理。冗长的官僚主义名称与他们在页面上的权重相比，携带的信息很低。 不要在变量名中包含变量类型的名称。 常量需要描述其存储的值的含义，而不是怎么使用它。 单字母变量可用于循环或逻辑分支，单词变量可用于参数或返回值，多词短语可用于函数和包这一级的声明。 单词可用于方法、接口和包 请记住，包的命名将成为用户引用它时采用的名称，确保这个名称更有意义。 让我们来看一个示例： 12345678910111213141516171819type Person struct &#123; Name string Age int&#125;// AverageAge returns the average age of people.func AverageAge(people []Person) int &#123; if len(people) == 0 &#123; return 0 &#125; var count, sum int for _, p := range people &#123; sum += p.Age count += 1 &#125; return sum / count&#125; 在这个示例中，范围变量p在定义之后只在接下来的一行使用。p在整页源码和函数执行过程中都只生存一小段时间。对p感兴趣的读者只需要查看两行代码即可。 与之形成对比的是，变量people在函数参数中定义，并且存在了 7 行，同理的还有sum和count，这他们使用了更长的名称，读者必须关注更广泛的代码行。 我也可以使用s而不是sum，用c（或n）而不是count，但这会将整个程序中的变量都聚集在相同的重要性上。我也可以使用p而不是people，但是这样又有一个问题，那就是for ... range循环中的变量又用什么？单数的 person 看起来也很奇怪，生存时间极短命名却比导出它的那个值更长。 Austin Luo：这里说的是，若数组people用变量名p，那么从数组中获取的每一个元素取名就成了问题，比如用person，那即使用person看起来也很奇怪，一方面是单数，一方面person的生存周期只有两行（很短），命名比生存周期更长的p（people）还长了。 TIP：跟使用空行在文档中分段一样，使用空行将函数执行过程分段。在函数AverageAge中有按顺序的三个操作。第一个是先决条件，检查当people为空时我们不会除零，第二个是累加总和和计数，最后一个是计算平均数。 上下文是关键绝大多数的命名建议都是根据上下文的，意识到这一点很重要。我喜欢称之为原则，而不是规则。 i和index 这两个标识符有什么不同？我们很难确切地说其中一个比另一个好，比如： 123for index := 0; index &lt; len(s); index++ &#123; //&#125; 上述代码的可读性，基本上都会认为比下面这段要强： 123for i := 0; i &lt; len(s); i++ &#123; //&#125; 但我表示不赞同。因为无论是i还是index，都是限定于for循环体的，更冗长的命名，并没有让我们更容易地理解这段代码。 话说回来，下面两段代码那一段可读性更强呢？ 1func (s *SNMP) Fetch(oid []int, index int) (int, error) 或者 1func (s *SNMP) Fetch(o []int, i int) (int, error) 在这个示例中，oid是SNMP对象 ID 的缩写，因此将其略写为 o 意味着开发者必须将他们在文档中看到的常规符号转换理解为代码中更短的符号。同样地，将index简略为i，减少了其作为SNMP消息的索引的含义。 TIP：在参数声明中不要混用长、短不同的命名风格。 命名中不要包含所属类型的名称正如你给宠物取名一样，你会给狗取名“汪汪”，给猫取名为“咪咪”，但不会取名为“汪汪狗”、“咪咪猫”。出于同样的原因，你也不应在变量名称中包含其类型的名称。 变量命名应该体现它的内容，而不是类型。我们来看下面这个例子： 1var usersMap map[string]*User 这样的命名有什么好处呢？我们能知道它是个 map，并且它与*User类型有关，这可能还不错。但是 Go 作为一种静态类型语言，它并不会允许我们在需要标量变量的地方意外地使用到这个变量，因此Map后缀实际上是多余的。 现在我们来看像下面这样定义变量又是什么情况： 1234var ( companiesMap map[string]*Company productsMap map[string]*Products) 现在这个范围内我们有了三个 map 类型的变量了：usersMap，companiesMap，以及 productsMap，所有这些都从字符串映射到了不同的类型。我们知道它们都是 map，我们也知道它们的 map 声明会阻止我们使用一个代替另一个——如果我们尝试在需要map[string]*User的地方使用companiesMap，编译器将抛出错误。在这种情况下，很明显Map后缀不会提高代码的清晰度，它只是编程时需要键入的冗余内容。（Austin Luo：陈旧的思维方式） 我的建议是，避免给变量加上与类型相关的任何后缀。 TIP：如果users不能描述得足够清楚，那usersMap也一定不能。 这个建议也适用于函数参数，比如： 12345type Config struct &#123; //&#125;func WriteConfig(w io.Writer, config *Config) 将*Config参数命名为config是多余的，我们知道它是个*Config，函数签名上写得很清楚。 在这种情况建议考虑conf或者c——如果生命周期足够短的话。 如果在一个范围内有超过一个*Config，那命名为conf1、conf2的描述性就比original、updated更差，而且后者比前者更不容易出错。 NOTE：不要让包名占用了更适合变量的名称 导入的标识符是会包含它所属包的名称的。例如我们很清楚context.Context是包context中的类型Context。这就导致我们在我们自己的包里，再也无法使用context作为变量或类型名了。func WriteLog(context context.Context, message string)这无法编译。这也是为什么我们通常将context.Context类型的变量命名为ctx的原因，如：func WriteLog(ctx context.Context, message string) 使用一致的命名风格一个好名字的另一个特点是它应该是可预测的。阅读者应该可以在第一次看到的时候就能够理解它如何使用。如果遇到一个约定俗称的名字，他们应该能够认为自从他们上次看到这个名字以来它没有改变意义。 例如，如果你要传递一个数据库句柄，请确保每次的参数命名都是一样的。与其使用d *sql.DB，dbase *sql.DB，DB *sql.DB和database *sql.DB，还不如都统一为： 1db *sql.DB 这样做可以增进熟悉度：如果你看到db，那么你就知道那是个*sql.DB，并且已经在本地定义或者由调用者提供了。 对于方法接收者也类似，在类型的每个方法中使用相同的接收者名称，这样可以让阅读者在跨方法阅读和理解时更容易主观推断。 Austin Luo：“接收者”是一种特殊类型的参数。^2比如func (b *Buffer) Read(p []byte) (n int, err error)，它通常只用一到两个字母来表示，但在不同的方法中仍然应当保持一致。 注意：Go 中对接收者的短命名规则惯例与目前提供的建议不一致。这只是早期做出的选择之一，并且已经成为首选的风格，就像使用CamelCase而不是snake_case一样。 TIP：Go 的命名风格规定接收器具有单个字母名称或其派生类型的首字母缩略词。有时您可能会发现接收器的名称有时会与方法中参数的名称冲突，在这种情况下，请考虑使参数名称稍长，并且仍然不要忘记一致地使用这个新名称。 最后，某些单字母变量传统上与循环和计数有关。例如，i，j，和k通常是简单的for循环变量。n通常与计数器或累加器有关。 v通常是某个值的简写，k通常用于映射的键，s通常用作string类型参数的简写。 与上面db的例子一样，程序员期望i是循环变量。如果你保证i始终是一个循环变量——而不是在for循环之外的情况下使用，那么当读者遇到一个名为i或者j的变量时，他们就知道当前还在循环中。 TIP：如果你发现在嵌套循环中你都使用完i，j，k了，那么很显然这已经到了将函数拆得更小的时候了。 使用一致的声明风格Go 中至少有 6 种声明变量的方法 var x int = 1 var x = 1 var x int; x = 1 var x = int(1) x := 1 我敢肯定还有更多我没想到的。这是 Go 的设计师认识到的可能是一个错误的地方，但现在改变它为时已晚。有这么多不同的方式来声明变量，那么我们如何避免每个 Go 程序员选择自己个性独特的声明风格呢？ 我想展示一些在我自己的程序里声明变量的建议。这是我尽可能使用的风格。 只声明，不初始化时，使用var。声明之后将显式地初始化时，使用var关键字。 123456var players int // 0var things []Thing // an empty slice of Thingsvar thing Thing // empty Thing structjson.Unmarshall(reader, &amp;thing) var关键字表明这个变量被有意地声明为该类型的零值。这也与在包级别声明变量时使用var而不是短声明语法（Austin Luo：:=）的要求一致——尽管我稍后会说你根本不应该使用包级变量。 既声明，也初始化时，使用:=。当同时要声明和初始化变量时，换言之我们不让变量隐式地被初始化为零值时，我建议使用短声明语法的形式。这使得读者清楚地知道:=左侧的变量是有意被初始化的。 为解释原因，我们回头再看看上面的例子，但这一次每个变量都被有意初始化了： 123456var players int = 0var things []Thing = nilvar thing *Thing = new(Thing)json.Unmarshall(reader, thing) 第一个和第三个示例中，因为 Go 没有从一种类型到另一种类型的自动转换，赋值运算符左侧和右侧的类型必定是一致的。编译器可以从右侧的类型推断出左侧声明的变量的类型。对于这个示例可以更简洁地写成这样： 123456var players = 0var things []Thing = nilvar thing = new(Thing)json.Unmarshall(reader, thing) 由于0是players的零值，因此为players显式地初始化为0就显得多余了。所以为了更清晰地表明我们使用了零值，应该写成这样： 1var players int 那第二条语句呢？我们不能忽视类型写成： 1var things = nil 因为nil根本就没有类型^2。相反，我们有一个选择，我们是否希望切片的零值？ 1var things []Thing 或者我们是否希望创建一个没有元素的切片？ 1var things = make([]Thing, 0) 如果我们想要的是后者，这不是个切片类型的零值，那么我们应该使用短声明语法让阅读者很清楚地明白我们的选择： 1things := make([]Thing, 0) 这告诉了读者我们显式地初始化了things。 再来看看第三个声明： 1var thing = new(Thing) 这既显式地初始化了变量，也引入了 Go 程序员不喜欢而且很不常用的new关键字。如果我们遵循短命名语法的建议，那么这句将变成： 1thing := new(Thing) 这很清楚地表明，thing被显式地初始化为new(Thing)的结果——一个指向Thing的指针——但仍然保留了我们不常用的new。我们可以通过使用紧凑结构初始化的形式来解决这个问题， 1thing := &amp;Thing&#123;&#125; 这和new(Thing)做了同样的事——也因此很多 Go 程序员对这种重复感觉不安。不过，这一句仍然意味着我们为thing明确地初始化了一个Thing{}的指针——一个Thing的零值。 在这里，我们应该意识到，thing被初始化为了零值，并且将它的指针地址传递给了json.Unmarshall： 12var thing Thingjson.Unmarshall(reader, &amp;thing)]]></content>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在 Visual Studio Code 中使用 MINGW32 作为终端]]></title>
    <url>%2F2018%2F10%2F08%2F%E5%9C%A8-Visual-Studio-Code-%E4%B8%AD%E4%BD%BF%E7%94%A8-MINGW32-%E4%BD%9C%E4%B8%BA%E7%BB%88%E7%AB%AF%2F</url>
    <content type="text"><![CDATA[打开 Visual Studio Code 的设置，按如下配置即可： 12345&#123; // 找到您的 git 目录 "terminal.integrated.shell.windows": "C:\\Program Files (x86)\\Git\\bin\\bash.exe", "terminal.integrated.shellArgs.windows": ["--login", "-i"]&#125;]]></content>
      <tags>
        <tag>VSC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 环境一键打包发布脚本]]></title>
    <url>%2F2018%2F10%2F06%2FLinux-%E7%8E%AF%E5%A2%83%E4%B8%80%E9%94%AE%E6%89%93%E5%8C%85%E5%8F%91%E5%B8%83%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[以下脚本作为工作笔记沉淀，记录一下。 deploy.sh 123456789101112131415161718192021222324252627282930313233#!/bin/sh# 本脚本用于开发环境，直接打包需要发布的文件，然后通过 SSH 复制到服务器并直接通过 pm2 启动执行。# 主要功能：# - 打包本地文件# - 剪切备份 $BUILDDIR 目录（实际程序执行的目录）# - 复制到远程服务器 $BUILDDIR 目录# - 解压# - 使用备份的配置文件覆盖# - 启动程序WORKROOT=/path/to/your/dir/on/remote/serverBUILDDIR=$WORKROOT/buildSKEY=" -i ~/.ssh/your-ssh-key-file"SCHANNEL="your-ssh-user@your-ssh-host"SROOT=$SCHANNEL:$WORKROOTSBUILD=$SCHANNEL:$BUILDDIRDATE=`date '+%Y-%m-%d%H%M%S'`. ./bash/pack.sh $DATEecho "copying files..."scp $SKEY -r ./build/build-$DATE.zip $SROOTssh $SKEY $SCHANNEL mv $BUILDDIR $BUILDDIR-$DATEecho "unzipping files..."ssh $SKEY $SCHANNEL unzip -q $WORKROOT/build-$DATE.zip -d $BUILDDIR#ssh $SKEY $SCHANNEL cp $WORKROOT/bak/etc/config.json $BUILDDIR/etc/config.jsonecho "starting..."CMD="cd $BUILDDIR ; pm2 restart ./etc/pm2.config.json"ssh $SKEY $SCHANNEL $CMD pack.sh 12345678910111213141516171819202122232425262728293031#!/bin/sh# 需要在项目根目录执行，如：./bash/pack.shDATE=$1if [ -z "$DATE" ] ; then DATE=`date '+%Y-%m-%d%H%M%S'`fi# 备份本地配置，使用生产环境配置mv ./etc/config.json ./etc/config.dev.json.bakmv ./etc/config.prod.json ./etc/config.jsonecho "packing files..."zip -r -q ./build/build-$DATE.zip ./binzip -r -q ./build/build-$DATE.zip ./dalzip -r -q ./build/build-$DATE.zip ./etc -i ./etc/*.jsonzip -r -q ./build/build-$DATE.zip ./controllerzip -r -q ./build/build-$DATE.zip ./middlewareszip -r -q ./build/build-$DATE.zip ./modelszip -r -q ./build/build-$DATE.zip ./node_moduleszip -r -q ./build/build-$DATE.zip ./publiczip -r -q ./build/build-$DATE.zip ./routeszip -r -q ./build/build-$DATE.zip ./utilszip -r -q ./build/build-$DATE.zip ./viewszip -r -q ./build/build-$DATE.zip ./app.js# 还原配置mv ./etc/config.json ./etc/config.prod.jsonmv ./etc/config.dev.json.bak ./etc/config.json]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>DevOps</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过 SSH 隧道链接远程 MySQL]]></title>
    <url>%2F2018%2F10%2F01%2F%E9%80%9A%E8%BF%87-SSH-%E9%9A%A7%E9%81%93%E9%93%BE%E6%8E%A5%E8%BF%9C%E7%A8%8B-MySQL%2F</url>
    <content type="text"><![CDATA[场景： SSH 跳板机：10.0.0.1 MySQL 数据库：10.0.0.2:3306 MySQL 部署的机器不允许 SSH 连接，并且数据库端口只允许 localhost 或 10.0.0.1 这台跳板机访问，此时本机可以通过 ssh 连上跳板机，通过 ssh 建立的隧道端口转发连接上 MySQL 数据库。 1234567891011# 本机连接跳板机# 打开本机 13306 端口，代理到 ssh 跳板机，并且通过跳板机访问 10.0.0.2:3306ssh -fCPN -L localhost:13306:10.0.0.2:3306 root@10.0.0.1# 参数解释# -C 使用压缩功能,是可选的,加快速度.# -P 用一个非特权端口进行出去的连接.# -f 一旦SSH完成认证并建立port forwarding,则转入后台运行.# -N 不执行远程命令.该参数在只打开转发端口时很有用（V2版本SSH支持）# 连接 MySQLmysql -uusername -ppassword -hlocalhost -P13306 参考： http://mingxinglai.com/cn/2015/09/connect-mysql-via-ssh-tunnel/]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Understanding Architecture]]></title>
    <url>%2F2018%2F09%2F30%2FUnderstanding-Architecture%2F</url>
    <content type="text"><![CDATA[架构是这样定义的 每个系统都有一个架构 架构由架构元素以及相互之间的关系构成 系统是为了满足 利益相关者（stakeholder） 的需求而构建的 利益相关者都有自己的关注点（concerns） 架构由架构文档描述 架构文档描述了一系列的架构视角 每个视角都解决并且对应到利益相关者的关注点。 架构师的首要任务是尽最大可能找出所有利益相关者，业务方，产品经理，客户/用户，开发经理，工程师，项目经理，测试人员，运维人员，产品运营人员等等都有可能是利益相关者，架构师要充分和利益相关者沟通，深入理解他们的关注点和痛点，并出架构解决这些关注点。架构师常犯错误是漏掉重要的利益相关者，沟通不充分，都会造成架构有欠缺，不能满足利益相关者的需求。利益相关者的关注点是有可能冲突的，比如管理层（可管理性）vs技术方（性能），业务方（多快好省）vs 技术方（可靠稳定），这需要架构师去灵活平衡，如何平衡体现了架构师的水平和价值。 Architecture represents the significant design decisions that shape a system, where significant is measured by cost of change. —- Grady Booch, UML的创始人之一 架构表示对一个系统的成型起关键作用的设计决策，这里的关键性是由“改变它”的成本来决定的。 微服务中每个服务可以独立演变，它的cost of change比较小，整体架构比较灵活，是一种支持创新的演化式架构。 Architecture Requirements Requirement Feature Description Easy to separate Autonomy 易分离，自治性 Easy to understand Understandablility 可理解性 Easy to extend Extensibility 可延展性 Easy to change Changeability 可变性 Easy to replace Replaceability 可替换性 Easy to deploy Deployability 可部署性 Easy to scale Scalability 伸缩性，可扩展性 Easy to recover Resilience 可恢复性 Easy to connect Uniform interface 易连接，易集成，统一接口 Easy to afford Cost-efficiency 成本效率，性价比 架构的目标是用于管理复杂性、易变性和不确定性，以确保在长期的系统演化过程中，一部分架构的变化不会对架构的其它部分产生不必要的负面影响。这样做可以确保业务和研发效率的敏捷，让应用的易变部分能够频繁地变化，对应用的其它部分的影响尽可能的小。 微服务更多是关于组织和团队，而不是技术 organizations which design systems … are constrained to produce designs which are copies of the communication structures of these organizations. 康威定律：设计系统的组织，其产生的设计和架构等价于组织间的沟通结构.]]></content>
      <tags>
        <tag>Architecture</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kubernetes 环境搭建]]></title>
    <url>%2F2018%2F09%2F30%2FKubernetes%2F</url>
    <content type="text"><![CDATA[kubernetes 安装 VM 驱动 - VirtualBox - KVM2 - 其他驱动 安装 kubectl 安装 minikube 运行 拉取 k8s 相关镜像 Kubenetes 向 kubernetes 添加账号 相关问题 failed to create kubelet: misconfiguration: kubelet cgroup driver: “cgroupfs” is different from docker cgr…driver: “systemd” [ERROR FileContent–proc-sys-net-bridge-bridge-nf-call-iptables]: /proc/sys/net/bridge/bridge-nf-call-iptables contents are not set to 1 Unable to update cni config: No networks found in /etc/cni/net.d 参考 kubernetes指引：https://kubernetes.io/docs/tasks/tools/install-kubectl/ 安装 VM 驱动 腾讯云 CVM 未能启用驱动启动 minikube，安装驱动的过程可忽略。 - VirtualBox CentOS：虚拟机不支持内部 VM，未在物理机上尝试 123456789cd /etc/yum.repos.d/wget http://download.virtualbox.org/virtualbox/rpm/rhel/virtualbox.repoyum updaterpm -Uvh https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpmyum install -y binutils gcc make patch libgomp glibc-headers glibc-devel kernel-headers kernel-devel dkmsyum install -y VirtualBox-5.2service vboxdrv start https://www.if-not-true-then-false.com/2010/install-virtualbox-with-yum-on-fedora-centos-red-hat-rhel/ https://www.virtualbox.org/wiki/Linux_Downloads https://www.cnblogs.com/harry-h/p/6405433.html MAC 上可以直接下载安装：https://www.virtualbox.org/wiki/Downloads - KVM2 安装成功，但 minikube start 时未能尝试成功 https://github.com/kubernetes/minikube/blob/master/docs/drivers.md#kvm2-driver 123456yum -y install libvirt-daemon-kvm qemu-kvmcurl -Lo docker-machine-driver-kvm2 https://storage.googleapis.com/minikube/releases/latest/docker-machine-driver-kvm2 \&amp;&amp; chmod +x docker-machine-driver-kvm2 \&amp;&amp; sudo cp docker-machine-driver-kvm2 /usr/local/bin/ \&amp;&amp; rm docker-machine-driver-kvm2 附：查看虚拟机网络以及使用不同的网络启动 minikube 12345yum -y install libvirt virt-install bridge-utils# 查看虚拟机网络virsh net-list --all# 使用不同的虚拟机网络(minikube-net)minikube start --vm-driver kvm2 --kvm-network minikube-net - 其他驱动指引：https://github.com/kubernetes/minikube/blob/master/docs/drivers.md#kvm-driver 安装 kubectl1234567891011121314151617181920212223# CentOScat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo[kubernetes]name=Kubernetesbaseurl=https://packages.cloud.google.com/yum/repos/kubernetes-el7-x86_64enabled=1gpgcheck=1repo_gpgcheck=1gpgkey=https://packages.cloud.google.com/yum/doc/yum-key.gpg https://packages.cloud.google.com/yum/doc/rpm-package-key.gpgEOFyum install -y kubectl# MAC: 方式一brew install kubernetes-cli# MAC：方式二curl -Lo kubectl http://storage.googleapis.com/kubernetes-release/release/v1.5.1/bin/darwin/amd64/kubectl &amp;&amp; chmod +x kubectl &amp;&amp; sudo mv kubectl /usr/local/bin/# 安装校验kubectl version# 确保服务已启动systemctl enable kubelet.servicesystemctl start kubelet.service 安装 minikube指引：https://github.com/kubernetes/minikube/releases 12345678# CentOScurl -Lo minikube https://storage.googleapis.com/minikube/releases/v0.29.0/minikube-linux-amd64 \ &amp;&amp; chmod +x minikube \ &amp;&amp; sudo cp minikube /usr/local/bin/ \ &amp;&amp; rm minikube# MACbrew cask install minikube 运行（使用 KVM2 驱动）运行之前 1234567891011# 启动服务systemctl enable libvirtd &amp;&amp; systemctl start libvirtd# 查看进程文件ls -l /var/run/libvirt/libvirt-sock# 若进程文件不存在，则修改配置：vi /etc/libvirt/libvirtd.conf# 取消行前注释，重新启动服务#unix_sock_dir = "/var/run/libvirt" 拉取 k8s 相关镜像原本在 minikube start 命令中会自动拉取镜像，但是因为众所周知的原因，我们无法成功拉取到镜像。这里可以使用阿里 docker 容器镜像服务：https://dev.aliyun.com/search.html 12345678910111213141516# 进入虚拟机拉取，而非本机minikube ssh# 拉取镜像docker pull registry.cn-hangzhou.aliyuncs.com/k8sth/kube-apiserver-amd64:v1.10.0docker pull registry.cn-hangzhou.aliyuncs.com/k8sth/kube-controller-manager-amd64:v1.10.0docker pull registry.cn-hangzhou.aliyuncs.com/k8sth/kube-scheduler-amd64:v1.10.0docker pull registry.cn-hangzhou.aliyuncs.com/k8sth/etcd-amd64:3.1.12docker pull registry.cn-shenzhen.aliyuncs.com/kubernetes_google/kubernetes-dashboard-amd64:v1.10.0# 修改 tagdocker tag registry.cn-hangzhou.aliyuncs.com/k8sth/kube-apiserver-amd64:v1.10.0 k8s.gcr.io/kube-apiserver-amd64:v1.10.0docker tag registry.cn-hangzhou.aliyuncs.com/k8sth/kube-controller-manager-amd64:v1.10.0 k8s.gcr.io/kube-controller-manager-amd64:v1.10.0docker tag registry.cn-hangzhou.aliyuncs.com/k8sth/kube-scheduler-amd64:v1.10.0 k8s.gcr.io/kube-scheduler-amd64:v1.10.0docker tag registry.cn-hangzhou.aliyuncs.com/k8sth/etcd-amd64:3.1.12 k8s.gcr.io/etcd-amd64:3.1.12docker tag registry.cn-shenzhen.aliyuncs.com/kubernetes_google/kubernetes-dashboard-amd64:v1.10.0 k8s.gcr.io/kubernetes-dashboard-amd64:v1.10.0 Kubenetes指引：https://kubernetes.io/docs/setup/minikube/#quickstart 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# 在代理下运行时，需要指定正确的代理，否则 minikube 在内部访问网络会有问题# 注意，代理地址应当是在虚拟机中能够访问的地址，不能使用 127.0.0.1、localhost 这种https_proxy=http://web-proxy.oa.com:8080minikube start \ --docker-env http_proxy=http://web-proxy.oa.com:8080 \ --docker-env https_proxy=http://web-proxy.oa.com:8080 \ --docker-env no_proxy=192.168.99.0/24 --vm-driver=none# 安装和启动过程中可能产生错误，通过该命令查看日志minikube logs -f# 启动 k8s（ CentOS 上不使用任何 vm 驱动，MAC 上默认可使用 VirtualBox）minikube start \ --network-plugin=cni \ --container-runtime=containerd \ --bootstrapper=kubeadm --vm-driver=none# Dashboard# https://github.com/kubernetes/dashboardkubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/master/src/deploy/recommended/kubernetes-dashboard.yamlkubectl proxy# 部署及运行镜像kubectl run hello-minikube --image=registry.cn-hangzhou.aliyuncs.com/acs/echoserver:1.4 --port=8080# 导出服务kubectl expose deployment hello-minikube --type=NodePort# 查询 Podkubectl get podkubectl get pods --all-namespaces# 查看状态kubectl describe --namespace=kube-system po kubernetes-dashboard-6f4cfc5d87-d647lkubectl logs kubernetes-dashboard-6f4cfc5d87-x976v --namespace=kube-systemkubectl cluster-info# 调用服务curl $(minikube service hello-minikube --url)# 删除服务kubectl delete services hello-minikube# 删除部署kubectl delete deployment hello-minikube# 停止 k8sminikube stop 向 kubernetes 添加账号https://github.com/kubernetes/dashboard/wiki/Creating-sample-user 相关问题failed to create kubelet: misconfiguration: kubelet cgroup driver: “cgroupfs” is different from docker cgr…driver: “systemd”该问题因为 docker 的配置和 kubelet 的配置不一致导致。 使用 docker info 打印 docker 信息： 123456[root@VM_0_16_centos kubelet.service.d]# docker info | grep Driver WARNING: Usage of loopback devices is strongly discouraged for production use. Use `--storage-opt dm.thinpooldev` to specify a custom block storage device. WARNING: You're not using the default seccomp profileStorage Driver: devicemapperLogging Driver: journaldCgroup Driver: systemd 而查看 kubelet 服务的启动参数（--cgroup-driver），其设置为 cgroupfs： 1234567891011[root@VM_0_16_centos kubelet.service.d]# more /etc/systemd/system/kubelet.service.d/10-kubeadm.conf[Unit]Wants=docker.socket[Service]ExecStart=ExecStart=/usr/bin/kubelet --hostname-override=minikube --cluster-domain=cluster.local --cgroup-driver=cgroupfs --authorization-mode=Webhook --client-ca-file=/var/lib/minikube/certs/ca.crt --fail-swap-on=false --kubeconfig=/etc/kubernetes/kubelet.conf --bootstrap-kubeconfig=/etc/kubernetes/bootstrap-kubelet.conf --pod-manifest-path=/etc/kubernetes/manifests --allow-privileged=true --cluster-dns=10.96.0.10 --cadvisor-port=0[Install] 此时，修改 docker 的服务参数（vi /usr/lib/systemd/system/docker.service），将其中的 --exec-opt native.cgroupdriver 参数值改为 cgroupfs 。 然后，重启 docker，重启 kubelet 1systemctl daemon-reload &amp;&amp; systemctl restart docker &amp;&amp; systemctl restart kubelet [ERROR FileContent–proc-sys-net-bridge-bridge-nf-call-iptables]: /proc/sys/net/bridge/bridge-nf-call-iptables contents are not set to 1解决方案：12echo 1 &gt; /proc/sys/net/bridge/bridge-nf-call-iptablesecho 1 &gt; /proc/sys/net/bridge/bridge-nf-call-ip6tables Unable to update cni config: No networks found in /etc/cni/net.d1yum install -y kubernetes-cni 参考https://www.jianshu.com/p/a42eeb66a19c]]></content>
      <tags>
        <tag>k8s</tag>
        <tag>kubernetes</tag>
        <tag>Micro Service</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一次 .NET Framework 不兼容 HTTP COOKIE 协议标准的问题跟踪]]></title>
    <url>%2F2018%2F06%2F15%2F%E8%AE%B0%E4%B8%80%E6%AC%A1-NET-Framework-%E4%B8%8D%E5%85%BC%E5%AE%B9-HTTP-COOKIE-%E5%8D%8F%E8%AE%AE%E6%A0%87%E5%87%86%E7%9A%84%E9%97%AE%E9%A2%98%E8%B7%9F%E8%B8%AA%2F</url>
    <content type="text"><![CDATA[我们在后端系统实现了 HTTP 请求的代理类，用于请求其他第三方系统。大致的请求流程是这样的： 消费系统不能直接请求业务系统的 HTTP 接口，需要由中间的 HttpHelper 代理请求。其中 HttpHelper 接受消费系统传入的各种参数，包括要请求的 URL、METHOD、HEAD、BODY 等，在实际生产中一直运行得很好，直到如下异常的出现： 12System.Net.CookieException: Cookie format error. at System.Net.CookieContainer.CookieCutter(Uri uri, String headerName, String setCookieHeader, Boolean isThrow) 跟进异常信息，很容易知道是设置 Cookie 时发生的异常。根据请求端传入的 HEAD 信息排查，我们很容易还原故障现场：传入 HTTP 头信息 Cookie: expires=Fri, 15 Jun 2018 15:19:14 GMT 这里是在设置 Cookie 的过期时间，并且这个时间看起来也正常，并没有格式错误或者时间不存在的错误。看起来问题不出在时间本身上。上网查查 HTTP 规范，根据 HTTP Cookie 协议，也是允许如下形式的字符串的，看起来也没有什么问题： 1Set-Cookie: sessionToken=abc123; Expires=Wed, 09 Jun 2021 10:18:14 GMT 既然异常是微软代码抛出来的，也给了具体抛出异常的方法的地方，那么我们就来翻翻微软代码吧。终于，在微软代码 System.Net.Cookie.VerifySetDefaults:L382 发现了问题所在。在这里，微软在校验 Cookie 值时，如果发现指定的值字符串中有保留字符（“,”、”;”），则要求该值必须使用双引号引起来，否则就会抛出异常。查看我们请求的头，在 expires 的值“Fri, 15 Jun 2018 15:19:14 GMT”中，的确有“,”存在，并且值也并未使用双引号引起来。于是我尝试修改传入的 HTTP 头参数： 1Cookie: expires=“Fri, 15 Jun 2018 15:19:14 GMT” 很自然，异常不再存在了，目前看起来的确是微软的这段代码导致了抛出异常。 你们我们来看看，这个值到底是不是可以去加双引号吧。继续上网翻文档，在 rfc2965#section-3.1 和 rfc6265#section-4.1.1 中提到，值可以是字符串或引号引起来的字符串（quoted-string），这是 在 HTTP State Management Mechanism 中有所规定的。那么我们可以很放心地做这个兼容性处理了，即，当传入的 Cookie 值包含保留字符，并且未被双引号引起来时（一定会产生异常），我们自动地追加双引号，把值引起来，这样既可避免微软对值进行严格校验时抛出异常了。 但是，此事还没有到此为止，我们实际来试试，加了双引号之后，业务系统是否能够正确收到消费系统传入的头呢？收到的头，是否为消费系统的正确意图呢？ 值得注意的是，在业务系统里获取到的 Cookie 值，是添加了引号的值，并不是严格地与消费系统里传入的文本一致。 到此为止，应对这个异常便有两个方案了： 传入的 Cookie 值包含保留字符，并且未被双引号引起来时（一定会产生异常），我们自动地追加双引号。 什么都不做，按原意抛出异常，提醒调用者更正 HTTP 头信息的格式。 在我们的项目中，由于情况特殊（使用场景为后端服务之间的通信交互），一般不涉及到 Cookie 的设置，并且消费服务可能由很多个不同的团队实现，而业务服务可以统一处理添加的双引号，因此我们采用了方案 1。至于其他场景，实际上个人偏向于采用方案 2，不掩盖任何问题——特别是因为加了双引号之后，请求接受端接收到的值，不能完全原样表达请求发起端设置的值。 参考： https://en.wikipedia.org/wiki/HTTP_cookie https://referencesource.microsoft.com/#System/net/System/Net/cookie.cs,67f8e4d3cb862668 https://referencesource.microsoft.com/#System/net/System/Net/cookie.cs,dca3e494aed8e006 https://tools.ietf.org/html/rfc6265#section-4.1.1 https://tools.ietf.org/html/rfc2965#section-3.1 https://tools.ietf.org/html/rfc2616]]></content>
      <tags>
        <tag>http</tag>
        <tag>.net</tag>
        <tag>Cookie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件系统的黑匣子：我们要怎样写日志]]></title>
    <url>%2F2018%2F02%2F28%2F%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E9%BB%91%E5%8C%A3%E5%AD%90%EF%BC%9A%E6%88%91%E4%BB%AC%E8%A6%81%E6%80%8E%E6%A0%B7%E5%86%99%E6%97%A5%E5%BF%97%2F</url>
    <content type="text"><![CDATA[引言作为一个软件系统，需要写日志，这是不言而喻的，这是大家都会不假思索地说“那当然”的事。不论是什么语言，写日志的专用框架也不一而足，写到文本的，写到数据库的，写到队列的，写到Redis的等等等等。对于日志的几个级别，Trace、Debug、Warning、Error、Fault，大家也能够如数家珍。但是，有多少人能够回答下面这几个问题呢？ 为什么需要写日志？什么时候写日志？日志是写给谁看的？日志里都要写什么？日志的组织形式应该怎样？ 接下来，我尝试一一地解答这些问题，说说我的理解。 为什么需要写日志首先我们要树立一个观点，那就是“不是为了记录日志而记录日志，日志也不是随意记的”。要实现能够只通过日志文件还原整个程序执行的过程，达到能透明地看到程序里执行情况，每个线程每个过程到底执行到哪的目的。日志就像飞机的黑匣子一样，应当能够复原异常的整个现场乃至细节。 作为程序员，我相信吐槽写注释、写文档的段子已经见得很多了。然而在我看来，写日志的重要性完全不亚于前两者，甚至在很多时候，比前两者更为重要。 我们说“软件工程”，很多人只着眼了“软件”两个字，而忽视了“工程”。软件本身是为解决问题服务的，作为一项工程，我们不单要考虑软件本身的开发环节（注释、文档），还应当考虑软件的运营环节（日志）。世界上没有100%完美的事，不存在没有 bug 的软件系统，一旦软件上线，作为开发人员的我们，就不再能够接触到了，如果系统发生了异常，我们却又对系统运行的状态一无所知，那我们就完全没有办法解决问题。有时候重启一下应用，重启一下系统什么的，也能临时解决，但这只是掩耳盗铃，该来的还会再来，出现过的异常，还会在某一天再次出现。 这个时候对“日志”的需求便应运而生。通过日志，记录程序在运行过程中的细节，记录发生异常时的现场，我们便能像庖丁解牛一样，对运行中的应用了如指掌了。 什么时候写日志所谓“麻雀虽小五脏俱全”，当我们在建构一个软件系统框架时，所谓的几层结构，所谓的基础模块（通用模块、工具模块、数据访问模块……），包括写日志的模块，这些方法都是不用思考，放之四海而皆准的东西，直接搭建/拼凑起来再说。 然后呢？我想很多人就开始闷头做功能了——我是指只写功能代码，完成实际的业务逻辑。在做业务功能的时候，由于现代IDE的调试功能很强大，可以一行一行调试，看到运行状态、变量状态等等，所以此时对日志的需求和功用是极度不敏感，觉得此时可有可无。但是一旦业务功能做完了，基于各种各样的理由，工期紧啊，已经完成功能了啊，就直接转测不再继续完善了。其结果是，功能的确完成了，但是搭建的日志模块却几乎没有使用。完成了整个系统，只有不痛不痒的两三行日志，大多都是在搭建框架时写的“应用启动了”，“应用停止了”一类。后面就不用说了，都说回头补设计文档，有多少人补了？都说回头补注释，有多少人补了？既然已经转测了，既然已经上线了，就更不会再回头去写日志了。 后来，可想而知，当生产环境除了问题，由于没有日志，到底出了什么异常，就两眼一抹黑，没人能知道了。终于，临时解决了问题，意识到日志的重要性之后，急急回头翻出代码来写日志，可是当时做业务的逻辑、思考、陷阱、注意事项等等，都忘记的差不多了，写日志也就只能像看陌生代码一样，看表面，“进入了XXX方法”，“插入数据库完成”，只能写这样的日志了。而在我看来，这样的日志是不够的，这也是我最反感的写日志的方式，完全是为了写而写——也是不足以还原故障现场的，这个后续再说。 说到此可能你应该也看出来的，什么时候写日志是最佳时机呢？那就是在开发功能代码时。可以说，日志本身也是属于功能代码的一部分，只不过业务功能是给最终客户的，而日志是给运维、开发等用的。此时写日志有一个巨大的好处，那就是因为你是一边在思考，一边在开发，那么此时业务流转、可能的异常都会考虑得很完善，写日志的过程，也是反复思考和校验逻辑的过程，也就自然而然地会在日志中体现更多的关键信息。 日志是写给谁看的 当然是给运维了啊，运维能够第一时间看到，比如日志中写端口被占用，马上改个端口就可以了！ 当然是给开发了啊，每次系统发生了异常，运维人员不是直接把日志给开发人员一丢就了事了吗？ 在我看来，不论是运维，还是开发，再广泛地讲，包括白盒测试，都是需要看日志的。日志对不同的人，都有不同的使用价值。运维通过日志了解到程序基本的安装、环境依赖、加载情况、运行态信息等等；开发通过日志还可以了解到程序对业务处理的信息，每个业务的流程、环节、现场状态等等；白盒测试也可以通过日志了解到程序要求的非功能特性等等。 日志里都要写什么明确了“为什么要写日志”和“日志写给谁看的”了之后，要回答“日志里都要写什么”就容易得多了。我们需要从多个侧面来想这个问题。 考虑使用者正如前文说，日志可能面向运维、面向开发等等不同身份的人群。因此日志的内容上，就要为不同的人写入其关切的入不同内容。 考虑业务这里的“业务”可能不一定是最终用户的业务，也可能是中间态的业务逻辑。当业务处理出现问题时，到底是程序的bug造成，还是错误的数据造成，或者是硬件、网络等资源的问题造成，这些都应当能够从日志中分析得出来。 一段日志，应当能够对故障现场的每一个细节都能在大脑思维里复盘。同时，日志不单单像流水账一样记录程序的运行过程，每行日志还不应该是孤立的，还应当是一个有机的整体，是有上下文的，有头有尾的。比如下面这一段日志： 日志中记录了一些关键事件以及一些关键信息。比如什么时候侦测到了新消息，有几个Handler可以去处理，每个Handler对应了哪个线程，每个线程对应在处理那种消息；有了某个处理过程的开始，就应当有对应的结束，如果涉及到多线程，还应当能够区分两行同样的日志，对应的不同线程和不同业务单据等等。而不仅仅是“侦测到消息”，“开始处理”，“处理完毕”这种简单的记录。 考虑运营对于业务，一般我们需要后续的分析和运营，日志在这方面也有起到较大作用，因此这部分日志应当考虑以结构化、规范化的方式来记录，从而方便后续对日志进行自动化分析。 考虑生命周期那么日志是越详细越好，记录得越多越好吗？是。也不是。 每一个软件系统都是有一定的生命周期的。刚测试上线的软件，一般最不稳定，最容易出现各种这样那样的问题，此时日志应当详细些。而长期运行了很久的软件，经过了时间、业务的大量考验，该出现的bug也已经修复得差不多了，几乎不会再出现什么问题，日志应当少一些。 怎么实现呢？很显然我们不能通过改代码，去掉写日志的代码之后重新发布来做这件事。常规地，我们通过日志分级来应对这个问题。通过不同的日志分级，以及日志输出开关，实时地调整日志输出的细节程度。因此，在我们编写输出日志的代码时，就务必要注意即将输出的日志应当是什么级别。Trace、Debug、Warning、Error、Fault，这些级别，应当对应不同重要程度、不同使用场景的细节。 考虑了以上三个方面，在开发完成之后，我们还应当切换不同的身份、角度以及配置不同的日志输出级别，来“设身处地”地审视输出的日志文件，是否能够满足要求，这样才能写一份好的日志记录。 日志的组织形式应该怎样既然叫“日志”，那我们通常的组织形式变是以时间为顺序来组织的一系列文件。除此之外，还可以将日志写入数据库、外部分析系统等等。 考虑“Separation of Concerns”，日志的组织形式，也可以根据上文考虑的不同方面来组织，比如将Error及以上的日志冗余独立记录，将面向运维的启停、加载信息独立记录，将软件运行日志和业务处理日志分开记录等等。关键是“Concern”，编写记录日志的代码时，我们应该对这段代码的功能、重要性、在整个系统的角色有深刻的认知，从而才能以不同的“关切”来考虑日志应该怎么输出，怎么组织。 综上当然，根据软件系统的不同，其日志的侧重点也可能不同。但总体来说，日志就如同飞机的黑匣子一样重要，我们应当重视日志输出的编写工作，而绝非仅仅是完成核心业务代码的编写。]]></content>
      <tags>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创建 VS 2017 的离线安装包]]></title>
    <url>%2F2017%2F11%2F15%2F%E5%88%9B%E5%BB%BA-VS-2017-%E7%9A%84%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%E5%8C%85%2F</url>
    <content type="text"><![CDATA[以下以 VS 的编译工具包为例，实际上 VS IDE 本身也可以如此进行。 一、下载在线安装文件 进入下载页：https://www.visualstudio.com/zh-hans/downloads/ 选择最底部的 Other Tools and Frameworks -&gt; Visual Studio 2017 生成工具 并下载。 以管理员身份运行刚刚下载的在线安装文件，注意带参数：--layout &quot;F:\software\VS2017 BuildTool\Offline&quot; --lang zh-CN 此时将开始下载安装所需文件：（如果断电断网或者关闭了下载窗口，没关系，输入命令重头来过，还是会继续下载的） 二、离线安装 打开刚刚存放离线文件的路径，然后找到certificates文件夹并打开，依次安装该文件夹下的软件证书。 运行离线根目录下的安装程序，各版本位置如下： 企业版：离线文件存储文件夹\vs_Enterprise.exe 专业版：离线文件存储文件夹\vs_Professional.exe 社区版：离线文件存储文件夹\vs_Community.exe 参考https://docs.microsoft.com/zh-cn/visualstudio/install/create-an-offline-installation-of-visual-studio https://www.ithome.com/html/win10/297093.htm]]></content>
      <tags>
        <tag>Visual Studio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是写程序的快感？]]></title>
    <url>%2F2017%2F04%2F21%2F%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%99%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%BF%AB%E6%84%9F%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[初中时，在电视里看office学习节目，对电脑无比神往。高二时，第一次开电脑上机课，两个人一台机学开机关机等基本操作，激动得大腿肌肉颤抖，在凳子上坐不住，坐两分钟蹲几分钟马步，实在会发抖，过了十几分钟才坐的住。这就是快感。 大学时，左边放着个水杯，码一阵代码后开启调试的间歇喝一口水，结果杯里的水喝完了，举着空杯喝一口空气。杯子放下继续码代码，直到第二次…第N次举着空水杯喝空气之后，仍然没有去把杯子续上，然而续水很远吗？不，水壶就在右手边。这就是快感。 临毕业，自己写一个博客程序，生生推倒重写3次，每一次都是质变。期间一个结构设计问题思考酝酿了很久，最终是半夜做梦突然来了灵感醒来，兴奋的再也睡不着了，马上一个激灵起来实现。整个博客程序完成之后无意看到了head first设计模式，各种我操我操的感叹，尼玛怎么跟我想的一样？这就是快感。 毕业后，特别是做自己的练手项目，无论白天黑夜，总跟自己说，这个问题5分钟就能解决，然而第N个5分钟过去了，需求已经早扩大得无边无际了，还在继续，直到天亮仍然放不下。这就是快感。 这个清明节，做了两个 visual studio 插件，三天假两天都是凌晨5点睡觉的。刚刚才收到无警告报告（手上的项目每几个小时会上报运营报告，凌晨2点是个check point），一抬头，天就亮了。这就是快感。 非计算机专业，纯自学一路走来，唯有这快感激励我走到今天，提供我码每一行代码的动力。这么多年来，很多朋友、同事接私单业余做也收益可观，但我只做过两个帮忙性质的单子，是的，十年只两个。摸着良心说，挣钱还真不是我码代码的第一原因——虽然做过的小产品已经很多了，但从来都没有转化为经济。我还买不起房，并不是来体验生活的富二代。 这种示例还很多…五指朝上地说，没有半句虚言。 快感，就是着了魔。]]></content>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[后端视角的高性能、高可用设计概要]]></title>
    <url>%2F2017%2F03%2F23%2F%E5%90%8E%E7%AB%AF%E8%A7%86%E8%A7%92%E7%9A%84%E9%AB%98%E6%80%A7%E8%83%BD%E3%80%81%E9%AB%98%E5%8F%AF%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A6%82%E8%A6%81%2F</url>
    <content type="text"><![CDATA[高性能业务方面 将同步业务转化为异步业务 业务分级，柔性可用 减少不必要的数据库请求 业务解耦，降低关联性 应用方面 前端高性能设计（略） 使用缓存：多级缓存、分布式缓存 预加载、懒加载、延迟初始化 尽量减小交互接口数据包大小 尽量减少序列化、对象克隆 尽量减少跨进程、跨机器、跨网络访问 尽量减少在同步业务中使用事务 尽量减少锁的使用 使用乐观锁 尽量缩小锁的范围 尽量将低性能逻辑放到锁的范围之外 使用异步逻辑 队列削峰，先接受，后处理 尽量复用 线程：线程池 连接：长连接、连接池 数据库方面 数据库读写分离 优化 SQL 语句、表结构、索引等 硬件及部署方面 负载均衡 分离应用服务器和数据库服务器 高可用业务方面 快速拒绝：尽早拒绝不符合策略的请求 灰度推广、灰度上线：按部门、分时段 服务分级，柔性可用 应用方面 自动重试机制 单点重试 多点重试 超时机制 幂等设计 无状态设计 容错机制 登录时，创建 Staff 抛出“该员工不存在” 提高编码质量，减少异常 完善的测试准出 功能 性能 运维方面 状态报告及预警 KeepAlive 资源报告及预警 CPU、内存、硬盘、IO 业务报告及预警 QPS、TPS、SQL查询 PV、UV 日志 硬件及部署方面 核心业务与非核心业务分开部署 负载均衡、双机热备、主备 异地多活 其他 先思考，后动手。多思考，少蛮干。 严格要求自己，将出手的产品当做孩子一样对待]]></content>
      <tags>
        <tag>Architecture</tag>
        <tag>高可用</tag>
        <tag>高性能</tag>
      </tags>
  </entry>
</search>
