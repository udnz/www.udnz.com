<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[在 Visual Studio Code 中使用 MINGW32 作为终端]]></title>
    <url>%2F2018%2F10%2F08%2F%E5%9C%A8-Visual-Studio-Code-%E4%B8%AD%E4%BD%BF%E7%94%A8-MINGW32-%E4%BD%9C%E4%B8%BA%E7%BB%88%E7%AB%AF%2F</url>
    <content type="text"><![CDATA[打开 Visual Studio Code 的设置，按如下配置即可： 12345&#123; // 找到您的 git 目录 "terminal.integrated.shell.windows": "C:\\Program Files (x86)\\Git\\bin\\bash.exe", "terminal.integrated.shellArgs.windows": ["--login", "-i"]&#125;]]></content>
      <tags>
        <tag>VSC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 环境一键打包发布脚本]]></title>
    <url>%2F2018%2F10%2F06%2FLinux-%E7%8E%AF%E5%A2%83%E4%B8%80%E9%94%AE%E6%89%93%E5%8C%85%E5%8F%91%E5%B8%83%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[以下脚本作为工作笔记沉淀，记录一下。 deploy.sh 123456789101112131415161718192021222324252627282930313233#!/bin/sh# 本脚本用于开发环境，直接打包需要发布的文件，然后通过 SSH 复制到服务器并直接通过 pm2 启动执行。# 主要功能：# - 打包本地文件# - 剪切备份 $BUILDDIR 目录（实际程序执行的目录）# - 复制到远程服务器 $BUILDDIR 目录# - 解压# - 使用备份的配置文件覆盖# - 启动程序WORKROOT=/path/to/your/dir/on/remote/serverBUILDDIR=$WORKROOT/buildSKEY=" -i ~/.ssh/your-ssh-key-file"SCHANNEL="your-ssh-user@your-ssh-host"SROOT=$SCHANNEL:$WORKROOTSBUILD=$SCHANNEL:$BUILDDIRDATE=`date '+%Y-%m-%d%H%M%S'`. ./bash/pack.sh $DATEecho "copying files..."scp $SKEY -r ./build/build-$DATE.zip $SROOTssh $SKEY $SCHANNEL mv $BUILDDIR $BUILDDIR-$DATEecho "unzipping files..."ssh $SKEY $SCHANNEL unzip -q $WORKROOT/build-$DATE.zip -d $BUILDDIR#ssh $SKEY $SCHANNEL cp $WORKROOT/bak/etc/config.json $BUILDDIR/etc/config.jsonecho "starting..."CMD="cd $BUILDDIR ; pm2 restart ./etc/pm2.config.json"ssh $SKEY $SCHANNEL $CMD pack.sh 12345678910111213141516171819202122232425262728293031#!/bin/sh# 需要在项目根目录执行，如：./bash/pack.shDATE=$1if [ -z "$DATE" ] ; then DATE=`date '+%Y-%m-%d%H%M%S'`fi# 备份本地配置，使用生产环境配置mv ./etc/config.json ./etc/config.dev.json.bakmv ./etc/config.prod.json ./etc/config.jsonecho "packing files..."zip -r -q ./build/build-$DATE.zip ./binzip -r -q ./build/build-$DATE.zip ./dalzip -r -q ./build/build-$DATE.zip ./etc -i ./etc/*.jsonzip -r -q ./build/build-$DATE.zip ./controllerzip -r -q ./build/build-$DATE.zip ./middlewareszip -r -q ./build/build-$DATE.zip ./modelszip -r -q ./build/build-$DATE.zip ./node_moduleszip -r -q ./build/build-$DATE.zip ./publiczip -r -q ./build/build-$DATE.zip ./routeszip -r -q ./build/build-$DATE.zip ./utilszip -r -q ./build/build-$DATE.zip ./viewszip -r -q ./build/build-$DATE.zip ./app.js# 还原配置mv ./etc/config.json ./etc/config.prod.jsonmv ./etc/config.dev.json.bak ./etc/config.json]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>DevOps</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过 SSH 隧道链接远程 MySQL]]></title>
    <url>%2F2018%2F10%2F01%2F%E9%80%9A%E8%BF%87-SSH-%E9%9A%A7%E9%81%93%E9%93%BE%E6%8E%A5%E8%BF%9C%E7%A8%8B-MySQL%2F</url>
    <content type="text"><![CDATA[场景： SSH 跳板机：10.0.0.1 MySQL 数据库：10.0.0.2:3306 MySQL 部署的机器不允许 SSH 连接，并且数据库端口只允许 localhost 或 10.0.0.1 这台跳板机访问，此时本机可以通过 ssh 连上跳板机，通过 ssh 建立的隧道端口转发连接上 MySQL 数据库。 1234567891011# 本机连接跳板机# 打开本机 13306 端口，代理到 ssh 跳板机，并且通过跳板机访问 10.0.0.2:3306ssh -fCPN -L localhost:13306:10.0.0.2:3306 root@10.0.0.1# 参数解释# -C 使用压缩功能,是可选的,加快速度.# -P 用一个非特权端口进行出去的连接.# -f 一旦SSH完成认证并建立port forwarding,则转入后台运行.# -N 不执行远程命令.该参数在只打开转发端口时很有用（V2版本SSH支持）# 连接 MySQLmysql -uusername -ppassword -hlocalhost -P13306 参考： http://mingxinglai.com/cn/2015/09/connect-mysql-via-ssh-tunnel/]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Understanding Architecture]]></title>
    <url>%2F2018%2F09%2F30%2FUnderstanding-Architecture%2F</url>
    <content type="text"><![CDATA[架构是这样定义的 每个系统都有一个架构 架构由架构元素以及相互之间的关系构成 系统是为了满足 利益相关者（stakeholder） 的需求而构建的 利益相关者都有自己的关注点（concerns） 架构由架构文档描述 架构文档描述了一系列的架构视角 每个视角都解决并且对应到利益相关者的关注点。 架构师的首要任务是尽最大可能找出所有利益相关者，业务方，产品经理，客户/用户，开发经理，工程师，项目经理，测试人员，运维人员，产品运营人员等等都有可能是利益相关者，架构师要充分和利益相关者沟通，深入理解他们的关注点和痛点，并出架构解决这些关注点。架构师常犯错误是漏掉重要的利益相关者，沟通不充分，都会造成架构有欠缺，不能满足利益相关者的需求。利益相关者的关注点是有可能冲突的，比如管理层（可管理性）vs技术方（性能），业务方（多快好省）vs 技术方（可靠稳定），这需要架构师去灵活平衡，如何平衡体现了架构师的水平和价值。 Architecture represents the significant design decisions that shape a system, where significant is measured by cost of change. —- Grady Booch, UML的创始人之一 架构表示对一个系统的成型起关键作用的设计决策，这里的关键性是由“改变它”的成本来决定的。 微服务中每个服务可以独立演变，它的cost of change比较小，整体架构比较灵活，是一种支持创新的演化式架构。 Architecture Requirements Requirement Feature Description Easy to separate Autonomy 易分离，自治性 Easy to understand Understandablility 可理解性 Easy to extend Extensibility 可延展性 Easy to change Changeability 可变性 Easy to replace Replaceability 可替换性 Easy to deploy Deployability 可部署性 Easy to scale Scalability 伸缩性，可扩展性 Easy to recover Resilience 可恢复性 Easy to connect Uniform interface 易连接，易集成，统一接口 Easy to afford Cost-efficiency 成本效率，性价比 架构的目标是用于管理复杂性、易变性和不确定性，以确保在长期的系统演化过程中，一部分架构的变化不会对架构的其它部分产生不必要的负面影响。这样做可以确保业务和研发效率的敏捷，让应用的易变部分能够频繁地变化，对应用的其它部分的影响尽可能的小。 微服务更多是关于组织和团队，而不是技术 organizations which design systems … are constrained to produce designs which are copies of the communication structures of these organizations. 康威定律：设计系统的组织，其产生的设计和架构等价于组织间的沟通结构.]]></content>
      <tags>
        <tag>Architecture</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kubernetes 环境搭建]]></title>
    <url>%2F2018%2F09%2F30%2FKubernetes%2F</url>
    <content type="text"><![CDATA[kubernetes 安装 VM 驱动 - VirtualBox - KVM2 - 其他驱动 安装 kubectl 安装 minikube 运行 拉取 k8s 相关镜像 Kubenetes 向 kubernetes 添加账号 相关问题 failed to create kubelet: misconfiguration: kubelet cgroup driver: “cgroupfs” is different from docker cgr…driver: “systemd” [ERROR FileContent–proc-sys-net-bridge-bridge-nf-call-iptables]: /proc/sys/net/bridge/bridge-nf-call-iptables contents are not set to 1 Unable to update cni config: No networks found in /etc/cni/net.d 参考 kubernetes指引：https://kubernetes.io/docs/tasks/tools/install-kubectl/ 安装 VM 驱动 腾讯云 CVM 未能启用驱动启动 minikube，安装驱动的过程可忽略。 - VirtualBox CentOS：虚拟机不支持内部 VM，未在物理机上尝试 123456789cd /etc/yum.repos.d/wget http://download.virtualbox.org/virtualbox/rpm/rhel/virtualbox.repoyum updaterpm -Uvh https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpmyum install -y binutils gcc make patch libgomp glibc-headers glibc-devel kernel-headers kernel-devel dkmsyum install -y VirtualBox-5.2service vboxdrv start https://www.if-not-true-then-false.com/2010/install-virtualbox-with-yum-on-fedora-centos-red-hat-rhel/ https://www.virtualbox.org/wiki/Linux_Downloads https://www.cnblogs.com/harry-h/p/6405433.html MAC 上可以直接下载安装：https://www.virtualbox.org/wiki/Downloads - KVM2 安装成功，但 minikube start 时未能尝试成功 https://github.com/kubernetes/minikube/blob/master/docs/drivers.md#kvm2-driver 123456yum -y install libvirt-daemon-kvm qemu-kvmcurl -Lo docker-machine-driver-kvm2 https://storage.googleapis.com/minikube/releases/latest/docker-machine-driver-kvm2 \&amp;&amp; chmod +x docker-machine-driver-kvm2 \&amp;&amp; sudo cp docker-machine-driver-kvm2 /usr/local/bin/ \&amp;&amp; rm docker-machine-driver-kvm2 附：查看虚拟机网络以及使用不同的网络启动 minikube 12345yum -y install libvirt virt-install bridge-utils# 查看虚拟机网络virsh net-list --all# 使用不同的虚拟机网络(minikube-net)minikube start --vm-driver kvm2 --kvm-network minikube-net - 其他驱动指引：https://github.com/kubernetes/minikube/blob/master/docs/drivers.md#kvm-driver 安装 kubectl1234567891011121314151617181920212223# CentOScat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo[kubernetes]name=Kubernetesbaseurl=https://packages.cloud.google.com/yum/repos/kubernetes-el7-x86_64enabled=1gpgcheck=1repo_gpgcheck=1gpgkey=https://packages.cloud.google.com/yum/doc/yum-key.gpg https://packages.cloud.google.com/yum/doc/rpm-package-key.gpgEOFyum install -y kubectl# MAC: 方式一brew install kubernetes-cli# MAC：方式二curl -Lo kubectl http://storage.googleapis.com/kubernetes-release/release/v1.5.1/bin/darwin/amd64/kubectl &amp;&amp; chmod +x kubectl &amp;&amp; sudo mv kubectl /usr/local/bin/# 安装校验kubectl version# 确保服务已启动systemctl enable kubelet.servicesystemctl start kubelet.service 安装 minikube指引：https://github.com/kubernetes/minikube/releases 12345678# CentOScurl -Lo minikube https://storage.googleapis.com/minikube/releases/v0.29.0/minikube-linux-amd64 \ &amp;&amp; chmod +x minikube \ &amp;&amp; sudo cp minikube /usr/local/bin/ \ &amp;&amp; rm minikube# MACbrew cask install minikube 运行（使用 KVM2 驱动）运行之前 1234567891011# 启动服务systemctl enable libvirtd &amp;&amp; systemctl start libvirtd# 查看进程文件ls -l /var/run/libvirt/libvirt-sock# 若进程文件不存在，则修改配置：vi /etc/libvirt/libvirtd.conf# 取消行前注释，重新启动服务#unix_sock_dir = "/var/run/libvirt" 拉取 k8s 相关镜像原本在 minikube start 命令中会自动拉取镜像，但是因为众所周知的原因，我们无法成功拉取到镜像。这里可以使用阿里 docker 容器镜像服务：https://dev.aliyun.com/search.html 12345678910111213141516# 进入虚拟机拉取，而非本机minikube ssh# 拉取镜像docker pull registry.cn-hangzhou.aliyuncs.com/k8sth/kube-apiserver-amd64:v1.10.0docker pull registry.cn-hangzhou.aliyuncs.com/k8sth/kube-controller-manager-amd64:v1.10.0docker pull registry.cn-hangzhou.aliyuncs.com/k8sth/kube-scheduler-amd64:v1.10.0docker pull registry.cn-hangzhou.aliyuncs.com/k8sth/etcd-amd64:3.1.12docker pull registry.cn-shenzhen.aliyuncs.com/kubernetes_google/kubernetes-dashboard-amd64:v1.10.0# 修改 tagdocker tag registry.cn-hangzhou.aliyuncs.com/k8sth/kube-apiserver-amd64:v1.10.0 k8s.gcr.io/kube-apiserver-amd64:v1.10.0docker tag registry.cn-hangzhou.aliyuncs.com/k8sth/kube-controller-manager-amd64:v1.10.0 k8s.gcr.io/kube-controller-manager-amd64:v1.10.0docker tag registry.cn-hangzhou.aliyuncs.com/k8sth/kube-scheduler-amd64:v1.10.0 k8s.gcr.io/kube-scheduler-amd64:v1.10.0docker tag registry.cn-hangzhou.aliyuncs.com/k8sth/etcd-amd64:3.1.12 k8s.gcr.io/etcd-amd64:3.1.12docker tag registry.cn-shenzhen.aliyuncs.com/kubernetes_google/kubernetes-dashboard-amd64:v1.10.0 k8s.gcr.io/kubernetes-dashboard-amd64:v1.10.0 Kubenetes指引：https://kubernetes.io/docs/setup/minikube/#quickstart 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# 在代理下运行时，需要指定正确的代理，否则 minikube 在内部访问网络会有问题# 注意，代理地址应当是在虚拟机中能够访问的地址，不能使用 127.0.0.1、localhost 这种https_proxy=http://web-proxy.oa.com:8080minikube start \ --docker-env http_proxy=http://web-proxy.oa.com:8080 \ --docker-env https_proxy=http://web-proxy.oa.com:8080 \ --docker-env no_proxy=192.168.99.0/24 --vm-driver=none# 安装和启动过程中可能产生错误，通过该命令查看日志minikube logs -f# 启动 k8s（ CentOS 上不使用任何 vm 驱动，MAC 上默认可使用 VirtualBox）minikube start \ --network-plugin=cni \ --container-runtime=containerd \ --bootstrapper=kubeadm --vm-driver=none# Dashboard# https://github.com/kubernetes/dashboardkubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/master/src/deploy/recommended/kubernetes-dashboard.yamlkubectl proxy# 部署及运行镜像kubectl run hello-minikube --image=registry.cn-hangzhou.aliyuncs.com/acs/echoserver:1.4 --port=8080# 导出服务kubectl expose deployment hello-minikube --type=NodePort# 查询 Podkubectl get podkubectl get pods --all-namespaces# 查看状态kubectl describe --namespace=kube-system po kubernetes-dashboard-6f4cfc5d87-d647lkubectl logs kubernetes-dashboard-6f4cfc5d87-x976v --namespace=kube-systemkubectl cluster-info# 调用服务curl $(minikube service hello-minikube --url)# 删除服务kubectl delete services hello-minikube# 删除部署kubectl delete deployment hello-minikube# 停止 k8sminikube stop 向 kubernetes 添加账号https://github.com/kubernetes/dashboard/wiki/Creating-sample-user 相关问题failed to create kubelet: misconfiguration: kubelet cgroup driver: “cgroupfs” is different from docker cgr…driver: “systemd”该问题因为 docker 的配置和 kubelet 的配置不一致导致。 使用 docker info 打印 docker 信息： 123456[root@VM_0_16_centos kubelet.service.d]# docker info | grep Driver WARNING: Usage of loopback devices is strongly discouraged for production use. Use `--storage-opt dm.thinpooldev` to specify a custom block storage device. WARNING: You're not using the default seccomp profileStorage Driver: devicemapperLogging Driver: journaldCgroup Driver: systemd 而查看 kubelet 服务的启动参数（--cgroup-driver），其设置为 cgroupfs： 1234567891011[root@VM_0_16_centos kubelet.service.d]# more /etc/systemd/system/kubelet.service.d/10-kubeadm.conf[Unit]Wants=docker.socket[Service]ExecStart=ExecStart=/usr/bin/kubelet --hostname-override=minikube --cluster-domain=cluster.local --cgroup-driver=cgroupfs --authorization-mode=Webhook --client-ca-file=/var/lib/minikube/certs/ca.crt --fail-swap-on=false --kubeconfig=/etc/kubernetes/kubelet.conf --bootstrap-kubeconfig=/etc/kubernetes/bootstrap-kubelet.conf --pod-manifest-path=/etc/kubernetes/manifests --allow-privileged=true --cluster-dns=10.96.0.10 --cadvisor-port=0[Install] 此时，修改 docker 的服务参数（vi /usr/lib/systemd/system/docker.service），将其中的 --exec-opt native.cgroupdriver 参数值改为 cgroupfs 。 然后，重启 docker，重启 kubelet 1systemctl daemon-reload &amp;&amp; systemctl restart docker &amp;&amp; systemctl restart kubelet [ERROR FileContent–proc-sys-net-bridge-bridge-nf-call-iptables]: /proc/sys/net/bridge/bridge-nf-call-iptables contents are not set to 1解决方案：12echo 1 &gt; /proc/sys/net/bridge/bridge-nf-call-iptablesecho 1 &gt; /proc/sys/net/bridge/bridge-nf-call-ip6tables Unable to update cni config: No networks found in /etc/cni/net.d1yum install -y kubernetes-cni 参考https://www.jianshu.com/p/a42eeb66a19c]]></content>
      <tags>
        <tag>k8s</tag>
        <tag>kubernetes</tag>
        <tag>Micro Service</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一次 .NET Framework 不兼容 HTTP COOKIE 协议标准的问题跟踪]]></title>
    <url>%2F2018%2F06%2F15%2F%E8%AE%B0%E4%B8%80%E6%AC%A1-NET-Framework-%E4%B8%8D%E5%85%BC%E5%AE%B9-HTTP-COOKIE-%E5%8D%8F%E8%AE%AE%E6%A0%87%E5%87%86%E7%9A%84%E9%97%AE%E9%A2%98%E8%B7%9F%E8%B8%AA%2F</url>
    <content type="text"><![CDATA[我们在后端系统实现了 HTTP 请求的代理类，用于请求其他第三方系统。大致的请求流程是这样的： 消费系统不能直接请求业务系统的 HTTP 接口，需要由中间的 HttpHelper 代理请求。其中 HttpHelper 接受消费系统传入的各种参数，包括要请求的 URL、METHOD、HEAD、BODY 等，在实际生产中一直运行得很好，直到如下异常的出现： 12System.Net.CookieException: Cookie format error. at System.Net.CookieContainer.CookieCutter(Uri uri, String headerName, String setCookieHeader, Boolean isThrow) 跟进异常信息，很容易知道是设置 Cookie 时发生的异常。根据请求端传入的 HEAD 信息排查，我们很容易还原故障现场：传入 HTTP 头信息 Cookie: expires=Fri, 15 Jun 2018 15:19:14 GMT 这里是在设置 Cookie 的过期时间，并且这个时间看起来也正常，并没有格式错误或者时间不存在的错误。看起来问题不出在时间本身上。上网查查 HTTP 规范，根据 HTTP Cookie 协议，也是允许如下形式的字符串的，看起来也没有什么问题： 1Set-Cookie: sessionToken=abc123; Expires=Wed, 09 Jun 2021 10:18:14 GMT 既然异常是微软代码抛出来的，也给了具体抛出异常的方法的地方，那么我们就来翻翻微软代码吧。终于，在微软代码 System.Net.Cookie.VerifySetDefaults:L382 发现了问题所在。在这里，微软在校验 Cookie 值时，如果发现指定的值字符串中有保留字符（“,”、”;”），则要求该值必须使用双引号引起来，否则就会抛出异常。查看我们请求的头，在 expires 的值“Fri, 15 Jun 2018 15:19:14 GMT”中，的确有“,”存在，并且值也并未使用双引号引起来。于是我尝试修改传入的 HTTP 头参数： 1Cookie: expires=“Fri, 15 Jun 2018 15:19:14 GMT” 很自然，异常不再存在了，目前看起来的确是微软的这段代码导致了抛出异常。 你们我们来看看，这个值到底是不是可以去加双引号吧。继续上网翻文档，在 rfc2965#section-3.1 和 rfc6265#section-4.1.1 中提到，值可以是字符串或引号引起来的字符串（quoted-string），这是 在 HTTP State Management Mechanism 中有所规定的。那么我们可以很放心地做这个兼容性处理了，即，当传入的 Cookie 值包含保留字符，并且未被双引号引起来时（一定会产生异常），我们自动地追加双引号，把值引起来，这样既可避免微软对值进行严格校验时抛出异常了。 但是，此事还没有到此为止，我们实际来试试，加了双引号之后，业务系统是否能够正确收到消费系统传入的头呢？收到的头，是否为消费系统的正确意图呢？ 值得注意的是，在业务系统里获取到的 Cookie 值，是添加了引号的值，并不是严格地与消费系统里传入的文本一致。 到此为止，应对这个异常便有两个方案了： 传入的 Cookie 值包含保留字符，并且未被双引号引起来时（一定会产生异常），我们自动地追加双引号。 什么都不做，按原意抛出异常，提醒调用者更正 HTTP 头信息的格式。 在我们的项目中，由于情况特殊（使用场景为后端服务之间的通信交互），一般不涉及到 Cookie 的设置，并且消费服务可能由很多个不同的团队实现，而业务服务可以统一处理添加的双引号，因此我们采用了方案 1。至于其他场景，实际上个人偏向于采用方案 2，不掩盖任何问题——特别是因为加了双引号之后，请求接受端接收到的值，不能完全原样表达请求发起端设置的值。 参考： https://en.wikipedia.org/wiki/HTTP_cookie https://referencesource.microsoft.com/#System/net/System/Net/cookie.cs,67f8e4d3cb862668 https://referencesource.microsoft.com/#System/net/System/Net/cookie.cs,dca3e494aed8e006 https://tools.ietf.org/html/rfc6265#section-4.1.1 https://tools.ietf.org/html/rfc2965#section-3.1 https://tools.ietf.org/html/rfc2616]]></content>
      <tags>
        <tag>http</tag>
        <tag>.net</tag>
        <tag>Cookie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件系统的黑匣子：我们要怎样写日志]]></title>
    <url>%2F2018%2F02%2F28%2F%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E9%BB%91%E5%8C%A3%E5%AD%90%EF%BC%9A%E6%88%91%E4%BB%AC%E8%A6%81%E6%80%8E%E6%A0%B7%E5%86%99%E6%97%A5%E5%BF%97%2F</url>
    <content type="text"><![CDATA[引言作为一个软件系统，需要写日志，这是不言而喻的，这是大家都会不假思索地说“那当然”的事。不论是什么语言，写日志的专用框架也不一而足，写到文本的，写到数据库的，写到队列的，写到Redis的等等等等。对于日志的几个级别，Trace、Debug、Warning、Error、Fault，大家也能够如数家珍。但是，有多少人能够回答下面这几个问题呢？ 为什么需要写日志？什么时候写日志？日志是写给谁看的？日志里都要写什么？日志的组织形式应该怎样？ 接下来，我尝试一一地解答这些问题，说说我的理解。 为什么需要写日志首先我们要树立一个观点，那就是“不是为了记录日志而记录日志，日志也不是随意记的”。要实现能够只通过日志文件还原整个程序执行的过程，达到能透明地看到程序里执行情况，每个线程每个过程到底执行到哪的目的。日志就像飞机的黑匣子一样，应当能够复原异常的整个现场乃至细节。 作为程序员，我相信吐槽写注释、写文档的段子已经见得很多了。然而在我看来，写日志的重要性完全不亚于前两者，甚至在很多时候，比前两者更为重要。 我们说“软件工程”，很多人只着眼了“软件”两个字，而忽视了“工程”。软件本身是为解决问题服务的，作为一项工程，我们不单要考虑软件本身的开发环节（注释、文档），还应当考虑软件的运营环节（日志）。世界上没有100%完美的事，不存在没有 bug 的软件系统，一旦软件上线，作为开发人员的我们，就不再能够接触到了，如果系统发生了异常，我们却又对系统运行的状态一无所知，那我们就完全没有办法解决问题。有时候重启一下应用，重启一下系统什么的，也能临时解决，但这只是掩耳盗铃，该来的还会再来，出现过的异常，还会在某一天再次出现。 这个时候对“日志”的需求便应运而生。通过日志，记录程序在运行过程中的细节，记录发生异常时的现场，我们便能像庖丁解牛一样，对运行中的应用了如指掌了。 什么时候写日志所谓“麻雀虽小五脏俱全”，当我们在建构一个软件系统框架时，所谓的几层结构，所谓的基础模块（通用模块、工具模块、数据访问模块……），包括写日志的模块，这些方法都是不用思考，放之四海而皆准的东西，直接搭建/拼凑起来再说。 然后呢？我想很多人就开始闷头做功能了——我是指只写功能代码，完成实际的业务逻辑。在做业务功能的时候，由于现代IDE的调试功能很强大，可以一行一行调试，看到运行状态、变量状态等等，所以此时对日志的需求和功用是极度不敏感，觉得此时可有可无。但是一旦业务功能做完了，基于各种各样的理由，工期紧啊，已经完成功能了啊，就直接转测不再继续完善了。其结果是，功能的确完成了，但是搭建的日志模块却几乎没有使用。完成了整个系统，只有不痛不痒的两三行日志，大多都是在搭建框架时写的“应用启动了”，“应用停止了”一类。后面就不用说了，都说回头补设计文档，有多少人补了？都说回头补注释，有多少人补了？既然已经转测了，既然已经上线了，就更不会再回头去写日志了。 后来，可想而知，当生产环境除了问题，由于没有日志，到底出了什么异常，就两眼一抹黑，没人能知道了。终于，临时解决了问题，意识到日志的重要性之后，急急回头翻出代码来写日志，可是当时做业务的逻辑、思考、陷阱、注意事项等等，都忘记的差不多了，写日志也就只能像看陌生代码一样，看表面，“进入了XXX方法”，“插入数据库完成”，只能写这样的日志了。而在我看来，这样的日志是不够的，这也是我最反感的写日志的方式，完全是为了写而写——也是不足以还原故障现场的，这个后续再说。 说到此可能你应该也看出来的，什么时候写日志是最佳时机呢？那就是在开发功能代码时。可以说，日志本身也是属于功能代码的一部分，只不过业务功能是给最终客户的，而日志是给运维、开发等用的。此时写日志有一个巨大的好处，那就是因为你是一边在思考，一边在开发，那么此时业务流转、可能的异常都会考虑得很完善，写日志的过程，也是反复思考和校验逻辑的过程，也就自然而然地会在日志中体现更多的关键信息。 日志是写给谁看的 当然是给运维了啊，运维能够第一时间看到，比如日志中写端口被占用，马上改个端口就可以了！ 当然是给开发了啊，每次系统发生了异常，运维人员不是直接把日志给开发人员一丢就了事了吗？ 在我看来，不论是运维，还是开发，再广泛地讲，包括白盒测试，都是需要看日志的。日志对不同的人，都有不同的使用价值。运维通过日志了解到程序基本的安装、环境依赖、加载情况、运行态信息等等；开发通过日志还可以了解到程序对业务处理的信息，每个业务的流程、环节、现场状态等等；白盒测试也可以通过日志了解到程序要求的非功能特性等等。 日志里都要写什么明确了“为什么要写日志”和“日志写给谁看的”了之后，要回答“日志里都要写什么”就容易得多了。我们需要从多个侧面来想这个问题。 考虑使用者正如前文说，日志可能面向运维、面向开发等等不同身份的人群。因此日志的内容上，就要为不同的人写入其关切的入不同内容。 考虑业务这里的“业务”可能不一定是最终用户的业务，也可能是中间态的业务逻辑。当业务处理出现问题时，到底是程序的bug造成，还是错误的数据造成，或者是硬件、网络等资源的问题造成，这些都应当能够从日志中分析得出来。 一段日志，应当能够对故障现场的每一个细节都能在大脑思维里复盘。同时，日志不单单像流水账一样记录程序的运行过程，每行日志还不应该是孤立的，还应当是一个有机的整体，是有上下文的，有头有尾的。比如下面这一段日志： 日志中记录了一些关键事件以及一些关键信息。比如什么时候侦测到了新消息，有几个Handler可以去处理，每个Handler对应了哪个线程，每个线程对应在处理那种消息；有了某个处理过程的开始，就应当有对应的结束，如果涉及到多线程，还应当能够区分两行同样的日志，对应的不同线程和不同业务单据等等。而不仅仅是“侦测到消息”，“开始处理”，“处理完毕”这种简单的记录。 考虑运营对于业务，一般我们需要后续的分析和运营，日志在这方面也有起到较大作用，因此这部分日志应当考虑以结构化、规范化的方式来记录，从而方便后续对日志进行自动化分析。 考虑生命周期那么日志是越详细越好，记录得越多越好吗？是。也不是。 每一个软件系统都是有一定的生命周期的。刚测试上线的软件，一般最不稳定，最容易出现各种这样那样的问题，此时日志应当详细些。而长期运行了很久的软件，经过了时间、业务的大量考验，该出现的bug也已经修复得差不多了，几乎不会再出现什么问题，日志应当少一些。 怎么实现呢？很显然我们不能通过改代码，去掉写日志的代码之后重新发布来做这件事。常规地，我们通过日志分级来应对这个问题。通过不同的日志分级，以及日志输出开关，实时地调整日志输出的细节程度。因此，在我们编写输出日志的代码时，就务必要注意即将输出的日志应当是什么级别。Trace、Debug、Warning、Error、Fault，这些级别，应当对应不同重要程度、不同使用场景的细节。 考虑了以上三个方面，在开发完成之后，我们还应当切换不同的身份、角度以及配置不同的日志输出级别，来“设身处地”地审视输出的日志文件，是否能够满足要求，这样才能写一份好的日志记录。 日志的组织形式应该怎样既然叫“日志”，那我们通常的组织形式变是以时间为顺序来组织的一系列文件。除此之外，还可以将日志写入数据库、外部分析系统等等。 考虑“Separation of Concerns”，日志的组织形式，也可以根据上文考虑的不同方面来组织，比如将Error及以上的日志冗余独立记录，将面向运维的启停、加载信息独立记录，将软件运行日志和业务处理日志分开记录等等。关键是“Concern”，编写记录日志的代码时，我们应该对这段代码的功能、重要性、在整个系统的角色有深刻的认知，从而才能以不同的“关切”来考虑日志应该怎么输出，怎么组织。 综上当然，根据软件系统的不同，其日志的侧重点也可能不同。但总体来说，日志就如同飞机的黑匣子一样重要，我们应当重视日志输出的编写工作，而绝非仅仅是完成核心业务代码的编写。]]></content>
      <tags>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创建 VS 2017 的离线安装包]]></title>
    <url>%2F2017%2F11%2F15%2F%E5%88%9B%E5%BB%BA-VS-2017-%E7%9A%84%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%E5%8C%85%2F</url>
    <content type="text"><![CDATA[以下以 VS 的编译工具包为例，实际上 VS IDE 本身也可以如此进行。 一、下载在线安装文件 进入下载页：https://www.visualstudio.com/zh-hans/downloads/ 选择最底部的 Other Tools and Frameworks -&gt; Visual Studio 2017 生成工具 并下载。 以管理员身份运行刚刚下载的在线安装文件，注意带参数：--layout &quot;F:\software\VS2017 BuildTool\Offline&quot; --lang zh-CN 此时将开始下载安装所需文件：（如果断电断网或者关闭了下载窗口，没关系，输入命令重头来过，还是会继续下载的） 二、离线安装 打开刚刚存放离线文件的路径，然后找到certificates文件夹并打开，依次安装该文件夹下的软件证书。 运行离线根目录下的安装程序，各版本位置如下： 企业版：离线文件存储文件夹\vs_Enterprise.exe 专业版：离线文件存储文件夹\vs_Professional.exe 社区版：离线文件存储文件夹\vs_Community.exe 参考https://docs.microsoft.com/zh-cn/visualstudio/install/create-an-offline-installation-of-visual-studio https://www.ithome.com/html/win10/297093.htm]]></content>
      <tags>
        <tag>Visual Studio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是写程序的快感？]]></title>
    <url>%2F2017%2F04%2F21%2F%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%99%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%BF%AB%E6%84%9F%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[初中时，在电视里看office学习节目，对电脑无比神往。高二时，第一次开电脑上机课，两个人一台机学开机关机等基本操作，激动得大腿肌肉颤抖，在凳子上坐不住，坐两分钟蹲几分钟马步，实在会发抖，过了十几分钟才坐的住。这就是快感。 大学时，左边放着个水杯，码一阵代码后开启调试的间歇喝一口水，结果杯里的水喝完了，举着空杯喝一口空气。杯子放下继续码代码，直到第二次…第N次举着空水杯喝空气之后，仍然没有去把杯子续上，然而续水很远吗？不，水壶就在右手边。这就是快感。 临毕业，自己写一个博客程序，生生推倒重写3次，每一次都是质变。期间一个结构设计问题思考酝酿了很久，最终是半夜做梦突然来了灵感醒来，兴奋的再也睡不着了，马上一个激灵起来实现。整个博客程序完成之后无意看到了head first设计模式，各种我操我操的感叹，尼玛怎么跟我想的一样？这就是快感。 毕业后，特别是做自己的练手项目，无论白天黑夜，总跟自己说，这个问题5分钟就能解决，然而第N个5分钟过去了，需求已经早扩大得无边无际了，还在继续，直到天亮仍然放不下。这就是快感。 这个清明节，做了两个 visual studio 插件，三天假两天都是凌晨5点睡觉的。刚刚才收到无警告报告（手上的项目每几个小时会上报运营报告，凌晨2点是个check point），一抬头，天就亮了。这就是快感。 非计算机专业，纯自学一路走来，唯有这快感激励我走到今天，提供我码每一行代码的动力。这么多年来，很多朋友、同事接私单业余做也收益可观，但我只做过两个帮忙性质的单子，是的，十年只两个。摸着良心说，挣钱还真不是我码代码的第一原因——虽然做过的小产品已经很多了，但从来都没有转化为经济。我还买不起房，并不是来体验生活的富二代。 这种示例还很多…五指朝上地说，没有半句虚言。 快感，就是着了魔。]]></content>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[后端视角的高性能、高可用设计概要]]></title>
    <url>%2F2017%2F03%2F23%2F%E5%90%8E%E7%AB%AF%E8%A7%86%E8%A7%92%E7%9A%84%E9%AB%98%E6%80%A7%E8%83%BD%E3%80%81%E9%AB%98%E5%8F%AF%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A6%82%E8%A6%81%2F</url>
    <content type="text"><![CDATA[高性能业务方面 将同步业务转化为异步业务 业务分级，柔性可用 减少不必要的数据库请求 业务解耦，降低关联性 应用方面 前端高性能设计（略） 使用缓存：多级缓存、分布式缓存 预加载、懒加载、延迟初始化 尽量减小交互接口数据包大小 尽量减少序列化、对象克隆 尽量减少跨进程、跨机器、跨网络访问 尽量减少在同步业务中使用事务 尽量减少锁的使用 使用乐观锁 尽量缩小锁的范围 尽量将低性能逻辑放到锁的范围之外 使用异步逻辑 队列削峰，先接受，后处理 尽量复用 线程：线程池 连接：长连接、连接池 数据库方面 数据库读写分离 优化 SQL 语句、表结构、索引等 硬件及部署方面 负载均衡 分离应用服务器和数据库服务器 高可用业务方面 快速拒绝：尽早拒绝不符合策略的请求 灰度推广、灰度上线：按部门、分时段 服务分级，柔性可用 应用方面 自动重试机制 单点重试 多点重试 超时机制 幂等设计 无状态设计 容错机制 登录时，创建 Staff 抛出“该员工不存在” 提高编码质量，减少异常 完善的测试准出 功能 性能 运维方面 状态报告及预警 KeepAlive 资源报告及预警 CPU、内存、硬盘、IO 业务报告及预警 QPS、TPS、SQL查询 PV、UV 日志 硬件及部署方面 核心业务与非核心业务分开部署 负载均衡、双机热备、主备 异地多活 其他 先思考，后动手。多思考，少蛮干。 严格要求自己，将出手的产品当做孩子一样对待]]></content>
      <tags>
        <tag>Architecture</tag>
        <tag>高可用</tag>
        <tag>高性能</tag>
      </tags>
  </entry>
</search>
