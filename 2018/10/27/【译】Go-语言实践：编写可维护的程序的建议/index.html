<!DOCTYPE html>












  


<html class="theme-next mist use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">






  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-big-counter.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.4.2" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.4.2">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.4.2">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.4.2">


  <link rel="mask-icon" href="/images/logo.svg?v=6.4.2" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '6.4.2',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="译者注 本文为 QCon 2018 上海站主题演讲嘉宾、Heptio 资深工程师、著名 Go 语言专家 David Cheney 关于 Go 语言实践的英文分享。为方便大家阅读，在此由 Austin Luo 翻译为中文，在文中难以理解之处，也特别增加了译者的理解说明。翻译水平有限，如有偏颇之处，烦请联系我（uonun@163.com）更正。转载请注明出处，保留本节译者注。  目录  指导原则 简单">
<meta name="keywords" content="Go">
<meta property="og:type" content="article">
<meta property="og:title" content="【译】Go 语言实践：编写可维护的程序的建议">
<meta property="og:url" content="https://www.udnz.com/2018/10/27/【译】Go-语言实践：编写可维护的程序的建议/index.html">
<meta property="og:site_name" content="UDNZ">
<meta property="og:description" content="译者注 本文为 QCon 2018 上海站主题演讲嘉宾、Heptio 资深工程师、著名 Go 语言专家 David Cheney 关于 Go 语言实践的英文分享。为方便大家阅读，在此由 Austin Luo 翻译为中文，在文中难以理解之处，也特别增加了译者的理解说明。翻译水平有限，如有偏颇之处，烦请联系我（uonun@163.com）更正。转载请注明出处，保留本节译者注。  目录  指导原则 简单">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2018-11-25T10:01:18.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="【译】Go 语言实践：编写可维护的程序的建议">
<meta name="twitter:description" content="译者注 本文为 QCon 2018 上海站主题演讲嘉宾、Heptio 资深工程师、著名 Go 语言专家 David Cheney 关于 Go 语言实践的英文分享。为方便大家阅读，在此由 Austin Luo 翻译为中文，在文中难以理解之处，也特别增加了译者的理解说明。翻译水平有限，如有偏颇之处，烦请联系我（uonun@163.com）更正。转载请注明出处，保留本节译者注。  目录  指导原则 简单">



  <link rel="alternate" href="/atom.xml" title="UDNZ" type="application/atom+xml" />




  <link rel="canonical" href="https://www.udnz.com/2018/10/27/【译】Go-语言实践：编写可维护的程序的建议/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>【译】Go 语言实践：编写可维护的程序的建议 | UDNZ</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">UDNZ</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签<span class="badge">17</span></a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档<span class="badge">12</span></a>
  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />搜索</a>
        </li>
      
    </ul>
  

  
    

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.udnz.com/2018/10/27/【译】Go-语言实践：编写可维护的程序的建议/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Austin Luo">
      <meta itemprop="description" content="架构师，腾讯<br />专注微服务和软件基础设施建设">
      <meta itemprop="image" content="https://avatars3.githubusercontent.com/u/934574?s=400&u=e82170d672ed95a22dfe72374fde752cf973b785&v=4">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="UDNZ">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">【译】Go 语言实践：编写可维护的程序的建议
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-10-27 23:08:18" itemprop="dateCreated datePublished" datetime="2018-10-27T23:08:18+08:00">2018-10-27</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-11-25 18:01:18" itemprop="dateModified" datetime="2018-11-25T18:01:18+08:00">2018-11-25</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><strong>译者注</strong></p>
<p>本文为 <strong>QCon 2018 上海站</strong>主题演讲嘉宾、Heptio 资深工程师、著名 Go 语言专家 <a href="https://2018.qconshanghai.com/speaker/2503" target="_blank" rel="noopener">David Cheney</a> 关于 Go 语言实践的英文分享。为方便大家阅读，在此由 <a href="https://www.udnz.com">Austin Luo</a> 翻译为中文，在文中难以理解之处，也特别增加了译者的理解说明。翻译水平有限，如有偏颇之处，烦请联系我（<a href="mailto:uonun@163.com" target="_blank" rel="noopener">uonun@163.com</a>）更正。转载请注明出处，保留本节译者注。</p>
<hr>
<p><strong>目录</strong></p>
<ul>
<li>指导原则<ul>
<li>简单性</li>
<li>可读性</li>
<li>生产率</li>
</ul>
</li>
<li>标识符<ul>
<li>选择清晰的名称，而不是简洁的名称</li>
<li>标识符长度</li>
<li>命名中不要包含所属类型的名称</li>
<li>使用一致的命名风格</li>
<li>使用一致的声明风格</li>
<li>成为团队合作者</li>
</ul>
</li>
<li>代码注释<ul>
<li>变量和常量上的注释应当描述它的内容，而非目的</li>
<li>总是为公开符号写文档说明</li>
</ul>
</li>
<li>包的设计<ul>
<li>一个好的包从它的名称开始</li>
<li>避免将包命名为 base、common、util</li>
<li>快速返回，而不是深层嵌套</li>
<li>让零值变得有意义</li>
<li>避免包级别的状态</li>
</ul>
</li>
<li>项目结构<ul>
<li>考虑更少，更大的包</li>
<li>确保 main 包越小越好</li>
</ul>
</li>
<li>API 设计<ul>
<li>设计难以被误用的 API</li>
<li>针对默认用例设计 API</li>
<li>让函数自身定义它所需的行为</li>
</ul>
</li>
<li>错误处理<ul>
<li>通过消除错误来消除错误处理</li>
<li>错误只处理一次</li>
</ul>
</li>
<li>并发<ul>
<li>保持自己忙碌，否则自己做</li>
<li>将并发留给调用者</li>
<li>不要启动一个永不停止的协程</li>
</ul>
</li>
</ul>
<p><strong>引言</strong></p>
<p>接下来这两场我将给大家一些编写 Go 代码的最佳实践。</p>
<p>今天这是一个研讨会风格的演讲，我会摒弃那些绚丽的 PPT，而是使用您们可以直接带走的文档。</p>
<blockquote>
<p>您可以在这里找到这个演讲最新的在线版本：<br><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a></p>
</blockquote>
<a id="more"></a>
<h1 id="指导原则"><a href="#指导原则" class="headerlink" title="指导原则"></a>指导原则</h1><p>我们要谈论在一个编程语言中的最佳实践，那么我们首先应该明确什么是“最佳”。如果您们听了我昨天那场讲演的话，您一定看到了来自 Go 团队的 Russ Cox 讲的一句话：</p>
<blockquote>
<p>软件工程，是您在编程过程中增加了工期或者开发人员之后发生的那些事。 — Russ Cox</p>
</blockquote>
<p>Russ 是在阐述软件“编程”和软件“工程”之间的区别，前者是您写的程序，而后者是一个让更多的人长期使用的产品。软件工程师会来来去去地更换，团队也会成长或者萎缩，需求也会发生变化，新的特性也会增加，bug 也会被修复，这就是软件“工程”的本质。</p>
<p>我可能是现场最早的 Go 语言用户，但与其说我的主张来自我的资历，不如说我今天讲的是真实来自于 Go 语言本身的指导原则，那就是：</p>
<ol>
<li>简单性</li>
<li>可读性</li>
<li>生产率</li>
</ol>
<blockquote>
<p>您可能已经注意到，我并没有提<strong>性能</strong>或者<strong>并发性</strong>。实际上有不少的语言执行效率比 Go 还要高，但它们一定没有 Go 这么简单。有些语言也以<strong>并发性</strong>为最高目标，但它们的可读性和生产率都不好。</p>
</blockquote>
<blockquote>
<p><strong>性能</strong>和<strong>并发性</strong>都很重要，但它们不如<strong>简单性</strong>、<strong>可读性</strong>和<strong>生产率</strong>那么重要。</p>
</blockquote>
<h2 id="简单性"><a href="#简单性" class="headerlink" title="简单性"></a>简单性</h2><p>为什么我们要力求简单，为什么简单对 Go 语言编程如此重要？</p>
<p>我们有太多的时候感叹“这段代码我看不懂”，是吧？我们害怕修改一丁点代码，生怕这一点修改就导致其他您不懂的部分出问题，而您又没办法修复它。</p>
<p>这就是复杂性。复杂性把可读的程序变得不可读，复杂性终结了很多软件项目。</p>
<p>简单性是 Go 的最高目标。无论我们写什么程序，我们都应该能一致认为它应当简单。</p>
<h2 id="可读性"><a href="#可读性" class="headerlink" title="可读性"></a>可读性</h2><blockquote>
<p>Readability is essential for maintainability. — Mark Reinhold, JVM language summit 2018<br>可读性对于可维护性至关重要。</p>
</blockquote>
<p>为什么 Go 代码的可读性如此重要？为什么我们应该力求可读性？</p>
<blockquote>
<p>Programs must be written for people to read, and only incidentally for machines to execute. — Hal Abelson and Gerald Sussman, Structure and Interpretation of Computer Programs<br>程序应该是写来被人阅读的，而只是顺带可以被机器执行。</p>
</blockquote>
<p>可阅读性对所有的程序——不仅仅是 Go 程序，都是如此之重要，是因为程序是人写的并且给其他人阅读的，事实上被机器所执行只是其次。</p>
<p>代码被阅读的次数，远远大于被编写的次数。一段小的代码，在它的整个生命周期，可能被阅读成百上千次。</p>
<blockquote>
<p>The most important skill for a programmer is the ability to effectively communicate ideas. — Gastón Jorquera <a href="https://gaston.life/books/effective-programming/" target="_blank" rel="noopener">^1</a><br>程序员最重要的技能是有效沟通想法的能力。</p>
</blockquote>
<p>可读性是弄清楚一个程序是在做什么事的关键。如果您都不知道这个程序在做什么，您如何去维护这个程序？如果一个软件不可用被维护，那就可能被重写，并且这也可能是您公司最后一次在 GO 上面投入了。</p>
<p>如果您仅仅是为自己个人写一个程序，可能这个程序是一次性的，或者使用这个程序的人也只有您一个，那您想怎样写就怎样写。但如果是多人合作贡献的程序，或者因为它解决人们的需求、满足某些特性、运行它的环境会变化，而在一个很长的时间内被很多人使用，那么程序的<strong>可维护性</strong>则必须成为目标。</p>
<p>编写可维护的程序的第一步，那就是确保代码是可读的。</p>
<h2 id="生产率"><a href="#生产率" class="headerlink" title="生产率"></a>生产率</h2><blockquote>
<p>Design is the art of arranging code to work today, and be changeable forever. — Sandi Metz<br>设计是一门艺术，要求编写的代码当前可用，并且以后仍能被改动。</p>
</blockquote>
<p>我想重点阐述的最后一个基本原则是<strong>生产率</strong>。开发者的生产率是一个复杂的话题，但归结起来就是：为了有效的工作，您因为一些工具、外部代码库而浪费了多少时间。Go 程序员应该感受得到，他们在工作中可以从很多东西中受益了。（Austin Luo：言下之意是，Go 的工具集和基础库完备，很多东西触手可得。）</p>
<p>有一个笑话是说，Go 是在 C++ 程序编译过程中被设计出来的。快速的编译是 Go 语言用以吸引新开发者的关键特性。编译速度仍然是一个不变的战场，很公平地说，其他语言需要几分钟才能编译，而 Go 只需要几秒即可完成。这有助于 Go 开发者拥有动态语言开发者一样的高效，但却不会面临那些动态语言本身可靠性的问题。</p>
<p>Go 开发者意识到代码是写来被阅读的，并且把<strong>阅读</strong>放在<strong>编写</strong>之上。Go 致力于从工具集、习惯等方面强制要求代码必须编写为一种特定样式，这消除了学习项目特定术语的障碍，同时也可以仅仅从“看起来”不正确即可帮助开发者发现潜在的错误。</p>
<p>Go 开发者不会整日去调试那些莫名其妙的编译错误。他们也不会整日浪费时间在复杂的构建脚本或将代码部署到生产中这事上。更重要的是他们不会花时间在尝试搞懂同事们写的代码是什么意思这事上。</p>
<p>当 Go 语言团队在谈论一个语言必须扩展时，他们谈论的就是生产率。</p>
<h1 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h1><p>我们要讨论的第一个议题是标识符。标识符是一个名称的描述词，这个名称可以是一个变量的名称、一个函数的名称、一个方法的名称、一个类型的名称或者一个包的名称等等。</p>
<blockquote>
<p>Poor naming is symptomatic of poor design. — Dave Cheney<br>拙劣的名称是拙劣的设计的表征。</p>
</blockquote>
<p>鉴于 Go 的语法限制，我们为程序中的事物选择的名称对我们程序的可读性产生了过大的影响。良好的可读性是评判代码质量的关键，因此选择好名称对于 Go 代码的可读性至关重要。</p>
<h2 id="选择清晰的名称，而不是简洁的名称"><a href="#选择清晰的名称，而不是简洁的名称" class="headerlink" title="选择清晰的名称，而不是简洁的名称"></a>选择清晰的名称，而不是简洁的名称</h2><blockquote>
<p>Obvious code is important. What you can do in one line you should do in three. — Ukiah Smith<br>代码要明确这很重要，您在一行中能做的事，应该拆到三行里做。</p>
</blockquote>
<p>Go 不是专注于将代码精巧优化为一行的那种语言，Go 也不是致力于将代码精炼到最小行数的语言。我们并不追求源码在磁盘上占用的空间更少，也不关心录入代码需要多长时间。</p>
<blockquote>
<p>Good naming is like a good joke. If you have to explain it, it’s not funny. — Dave Cheney<br>好的名称就如同一个好的笑话，如果您需要去解释它，那它就不搞笑了。</p>
</blockquote>
<p>这个清晰度的关键就是我们为 Go 程序选择的标识符。让我们来看看一个好的名称应当具备什么吧：</p>
<ul>
<li><strong>好的名称是简洁的。</strong>一个好的名称未必是尽可能短的，但它肯定不会浪费任何无关的东西在上面，好名字具有高信噪比。</li>
<li><strong>好的名称是描述性的。</strong>一个好的名称应该描述一个变量或常量的使用，而非其内容。一个好的命名应该描述函数的结果或一个方法的行为，而不是这个函数或方法本身的操作。一个好的名称应该描述一个包的目的，而不是包的内容。名称描述的东西越准确，名称越好。</li>
<li><strong>好的名称是可预测的。</strong>您应该能够从名称中推断出它的使用方式，这是选择描述性名称带来的作用，同时也遵循了传统。Go 开发者在谈论<strong>惯用语</strong>时，即是说的这个。</li>
</ul>
<p>接下来让我们深入地讨论一下。</p>
<h2 id="标识符长度"><a href="#标识符长度" class="headerlink" title="标识符长度"></a>标识符长度</h2><p>有时候人们批评 Go 风格推荐短变量名。正如 Rob Pike 所说，“Go 开发者想要的是合适长度的标识符”。<a href="https://gaston.life/books/effective-programming/" target="_blank" rel="noopener">^1</a></p>
<p>Andrew Gerrand 建议通过使用更长的标识符向读者暗示它们具有更高的重要性。</p>
<blockquote>
<p>The greater the distance between a name’s declaration and its uses, the longer the name should be. — Andrew Gerrand <a href="https://talks.golang.org/2014/names.slide#4" target="_blank" rel="noopener">^2</a><br>标识符的声明和使用间隔越远，名称的长度就应当越长。</p>
</blockquote>
<p>据此，我们可以归纳一些指导意见：</p>
<ul>
<li>短变量名称在声明和上次使用之间的距离很短时效果很好。</li>
<li>长变量名需要证明其不同的合理性：越长的变量名，越需要更多的理由来证明其合理。冗长、繁琐的名称与他们在页面上的权重相比，携带的信息很低。</li>
<li>不要在变量名中包含其类型的名称。</li>
<li>常量需要描述其存储的值的含义，而不是怎么使用它。</li>
<li>单字母变量可用于循环或逻辑分支，单词变量可用于参数或返回值，多词短语可用于函数和包这一级的声明。</li>
<li>单词可用于方法、接口和包</li>
<li>请记住，包的命名将成为用户引用它时采用的名称，确保这个名称更有意义。</li>
</ul>
<p>让我们来看一个示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">  Name <span class="keyword">string</span></span><br><span class="line">  Age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AverageAge returns the average age of people.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AverageAge</span><span class="params">(people []Person)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(people) == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> count, sum <span class="keyword">int</span></span><br><span class="line">  <span class="keyword">for</span> _, p := <span class="keyword">range</span> people &#123;</span><br><span class="line">    sum += p.Age</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> sum / count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，范围变量<code>p</code>在定义之后只在接下来的一行使用。<code>p</code>在整页源码和函数执行过程中都只生存一小段时间。对<code>p</code>感兴趣的读者只需要查看两行代码即可。</p>
<p>与之形成对比的是，变量<code>people</code>在函数参数中定义，并且存在了 7 行，同理的还有<code>sum</code>和<code>count</code>，这他们使用了更长的名称，读者必须关注更广泛的代码行。</p>
<p>我也可以使用<code>s</code>而不是<code>sum</code>，用<code>c</code>（或<code>n</code>）而不是<code>count</code>，但这会将整个程序中的变量都聚集在相同的重要性上。我也可以使用<code>p</code>而不是<code>people</code>，但是这样又有一个问题，那就是<code>for ... range</code>循环中的变量又用什么？单数的 <code>person</code> 看起来也很奇怪，生存时间极短命名却比导出它的那个值更长。</p>
<blockquote>
<p>Austin Luo：这里说的是，若数组<code>people</code>用变量名<code>p</code>，那么从数组中获取的每一个元素取名就成了问题，比如用<code>person</code>，即使使用<code>person</code>看起来也很奇怪，一方面是单数，一方面<code>person</code>的生存周期只有两行（很短），命名比生存周期更长的<code>p</code>（<code>people</code>）还长了。</p>
</blockquote>
<blockquote>
<p>小窍门：跟使用空行在文档中分段一样，使用空行将函数执行过程分段。在函数<code>AverageAge</code>中有按顺序的三个操作。第一个是先决条件，检查当<code>people</code>为空时我们不会除零，第二个是累加总和和计数，最后一个是计算平均数。</p>
</blockquote>
<h3 id="上下文是关键"><a href="#上下文是关键" class="headerlink" title="上下文是关键"></a>上下文是关键</h3><p>绝大多数的命名建议都是根据上下文的，意识到这一点很重要。我喜欢称之为原则，而不是规则。</p>
<p><code>i</code>和<code>index</code> 这两个标识符有什么不同？我们很难确切地说其中一个比另一个好，比如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> index := <span class="number">0</span>; index &lt; <span class="built_in">len</span>(s); index++ &#123;</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码的可读性，基本上都会认为比下面这段要强：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但我表示不赞同。因为无论是<code>i</code>还是<code>index</code>，都是限定于<code>for</code>循环体的，更冗长的命名，并没有让我们<strong>更容易</strong>地理解这段代码。</p>
<p>话说回来，下面两段代码那一段可读性更强呢？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *SNMP)</span> <span class="title">Fetch</span><span class="params">(oid []<span class="keyword">int</span>, index <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span></span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *SNMP)</span> <span class="title">Fetch</span><span class="params">(o []<span class="keyword">int</span>, i <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span></span><br></pre></td></tr></table></figure>
<p>在这个示例中，<code>oid</code>是<code>SNMP</code>对象 ID 的缩写，因此将其略写为 <code>o</code> 意味着开发者必须将他们在文档中看到的常规符号转换理解为代码中更短的符号。同样地，将<code>index</code>简略为<code>i</code>，减少了其作为<code>SNMP</code>消息的索引的含义。</p>
<blockquote>
<p>小窍门：在参数声明中不要混用长、短不同的命名风格。</p>
</blockquote>
<h2 id="命名中不要包含所属类型的名称"><a href="#命名中不要包含所属类型的名称" class="headerlink" title="命名中不要包含所属类型的名称"></a>命名中不要包含所属类型的名称</h2><p>正如您给宠物取名一样，您会给狗取名“汪汪”，给猫取名为“咪咪”，但不会取名为“汪汪狗”、“咪咪猫”。出于同样的原因，您也不应在变量名称中包含其类型的名称。</p>
<p>变量命名应该体现它的内容，而不是类型。我们来看下面这个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> usersMap <span class="keyword">map</span>[<span class="keyword">string</span>]*User</span><br></pre></td></tr></table></figure>
<p>这样的命名有什么好处呢？我们能知道它是个 map，并且它与<code>*User</code>类型有关，这可能还不错。但是 Go 作为一种静态类型语言，它并不会允许我们在需要标量变量的地方意外地使用到这个变量，因此<code>Map</code>后缀实际上是多余的。</p>
<p>现在我们来看像下面这样定义变量又是什么情况：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">  companiesMap <span class="keyword">map</span>[<span class="keyword">string</span>]*Company</span><br><span class="line">  productsMap <span class="keyword">map</span>[<span class="keyword">string</span>]*Products</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>现在这个范围内我们有了三个 map 类型的变量了：<code>usersMap</code>，<code>companiesMap</code>，以及 <code>productsMap</code>，所有这些都从字符串映射到了不同的类型。我们知道它们都是 map，我们也知道它们的 map 声明会阻止我们使用一个代替另一个——如果我们尝试在需要<code>map[string]*User</code>的地方使用<code>companiesMap</code>，编译器将抛出错误。在这种情况下，很明显<code>Map</code>后缀不会提高代码的清晰度，它只是编程时需要键入的冗余内容。（Austin Luo：陈旧的思维方式）</p>
<p>我的建议是，避免给变量加上与类型相关的任何后缀。</p>
<blockquote>
<p>小窍门：如果<code>users</code>不能描述得足够清楚，那<code>usersMap</code>也一定不能。</p>
</blockquote>
<p>这个建议也适用于函数参数，比如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteConfig</span><span class="params">(w io.Writer, config *Config)</span></span></span><br></pre></td></tr></table></figure>
<p>将<code>*Config</code>参数命名为<code>config</code>是多余的，我们知道它是个<code>*Config</code>，函数签名上写得很清楚。</p>
<p>在这种情况建议考虑<code>conf</code>或者<code>c</code>——如果生命周期足够短的话。</p>
<p>如果在一个范围内有超过一个<code>*Config</code>，那命名为<code>conf1</code>、<code>conf2</code>的描述性就比<code>original</code>、<code>updated</code>更差，而且后者比前者更不容易出错。</p>
<blockquote>
<p>NOTE：<strong>不要让包名占用了更适合变量的名称。</strong><br>导入的标识符是会包含它所属包的名称的。<br>例如我们很清楚<code>context.Context</code>是包<code>context</code>中的类型<code>Context</code>。这就导致我们在我们自己的包里，再也无法使用<code>context</code>作为变量或类型名了。<br><code>func WriteLog(context context.Context, message string)</code><br>这无法编译。这也是为什么我们通常将<code>context.Context</code>类型的变量命名为<code>ctx</code>的原因，如：<br><code>func WriteLog(ctx context.Context, message string)</code></p>
</blockquote>
<h2 id="使用一致的命名风格"><a href="#使用一致的命名风格" class="headerlink" title="使用一致的命名风格"></a>使用一致的命名风格</h2><p>一个好名字的另一个特点是它应该是可预测的。阅读者应该可以在第一次看到的时候就能够理解它如何使用。如果遇到一个约定俗称的名字，他们应该能够认为和上次看到这个名字一样，一直以来它都没有改变意义。</p>
<p>例如，如果您要传递一个数据库句柄，请确保每次的参数命名都是一样的。与其使用<code>d *sql.DB</code>，<code>dbase *sql.DB</code>，<code>DB *sql.DB</code>和<code>database *sql.DB</code>，还不如都统一为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db *sql.DB</span><br></pre></td></tr></table></figure>
<p>这样做可以增进熟悉度：如果您看到<code>db</code>，那么您就知道那是个<code>*sql.DB</code>，并且已经在本地定义或者由调用者提供了。</p>
<p>对于方法接收者也类似，在类型的每个方法中使用相同的接收者名称，这样可以让阅读者在跨方法阅读和理解时更容易主观推断。</p>
<blockquote>
<p>Austin Luo：“接收者”是一种特殊类型的参数。<a href="https://talks.golang.org/2014/names.slide#4" target="_blank" rel="noopener">^2</a><br>比如<code>func (b *Buffer) Read(p []byte) (n int, err error)</code>，它通常只用一到两个字母来表示，但在不同的方法中仍然应当保持一致。</p>
</blockquote>
<blockquote>
<p>注意：Go 中对接收者的短命名规则惯例与目前提供的建议不一致。这只是早期做出的选择之一，并且已经成为首选的风格，就像使用<code>CamelCase</code>而不是<code>snake_case</code>一样。</p>
</blockquote>
<blockquote>
<p>小窍门：Go 的命名风格规定接收器具有单个字母名称或其派生类型的首字母缩略词。有时您可能会发现接收器的名称有时会与方法中参数的名称冲突，在这种情况下，请考虑使参数名称稍长，并且仍然不要忘记一致地使用这个新名称。</p>
</blockquote>
<p>最后，某些单字母变量传统上与循环和计数有关。例如，<code>i</code>，<code>j</code>，和<code>k</code>通常是简单的<code>for</code>循环变量。<code>n</code>通常与计数器或累加器有关。 <code>v</code>通常是某个值的简写，<code>k</code>通常用于映射的键，<code>s</code>通常用作<code>string</code>类型参数的简写。</p>
<p>与上面<code>db</code>的例子一样，程序员期望<code>i</code>是循环变量。如果您保证<code>i</code>始终是一个循环变量——而不是在<code>for</code>循环之外的情况下使用，那么当读者遇到一个名为<code>i</code>或者<code>j</code>的变量时，他们就知道当前还在循环中。</p>
<blockquote>
<p>小窍门：如果您发现在嵌套循环中您都使用完<code>i</code>，<code>j</code>，<code>k</code>了，那么很显然这已经到了将函数拆得更小的时候了。</p>
</blockquote>
<h2 id="使用一致的声明风格"><a href="#使用一致的声明风格" class="headerlink" title="使用一致的声明风格"></a>使用一致的声明风格</h2><p>Go 中至少有 6 种声明变量的方法（Austin Luo：作者说了 6 种，但只列了 5 种）</p>
<ul>
<li><code>var x int = 1</code></li>
<li><code>var x = 1</code></li>
<li><code>var x int; x = 1</code></li>
<li><code>var x = int(1)</code></li>
<li><code>x := 1</code></li>
</ul>
<p>我敢肯定还有更多我没想到的。这是 Go 的设计师认识到可能是一个错误的地方，但现在改变它为时已晚。有这么多不同的方式来声明变量，那么我们如何避免每个 Go 程序员选择自己个性独特的声明风格呢？</p>
<p>我想展示一些在我自己的程序里声明变量的建议。这是我尽可能使用的风格。</p>
<ul>
<li><p><strong>只声明，不初始化时，使用<code>var</code>。</strong>在声明之后，将会显式地初始化时，使用<code>var</code>关键字。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> players <span class="keyword">int</span>    <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> things []Thing <span class="comment">// an empty slice of Things</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> thing Thing    <span class="comment">// empty Thing struct</span></span><br><span class="line">json.Unmarshall(reader, &amp;thing)</span><br></pre></td></tr></table></figure>
<p><code>var</code>关键字表明这个变量被<strong>有意地</strong>声明为该类型的零值。这也与在包级别声明变量时使用<code>var</code>而不是短声明语法（Austin Luo：<code>:=</code>）的要求一致——尽管我稍后会说您根本不应该使用包级变量。</p>
</li>
<li><p><strong>既声明，也初始化时，使用<code>:=</code>。</strong>当同时要声明和初始化变量时，换言之我们不让变量隐式地被初始化为零值时，我建议使用短声明语法的形式。这使得读者清楚地知道<code>:=</code>左侧的变量是有意被初始化的。</p>
</li>
</ul>
<p>为解释原因，我们回头再看看上面的例子，但这一次每个变量都被有意初始化了：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> players <span class="keyword">int</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> things []Thing = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> thing *Thing = <span class="built_in">new</span>(Thing)</span><br><span class="line">json.Unmarshall(reader, thing)</span><br></pre></td></tr></table></figure>
<p>第一个和第三个示例中，因为 Go 没有从一种类型到另一种类型的自动转换，赋值运算符左侧和右侧的类型必定是一致的。编译器可以从右侧的类型推断出左侧所声明变量的类型。对于这个示例可以更简洁地写成这样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> players = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> things []Thing = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> thing = <span class="built_in">new</span>(Thing)</span><br><span class="line">json.Unmarshall(reader, thing)</span><br></pre></td></tr></table></figure>
<p>由于<code>0</code>是<code>players</code>的零值，因此为<code>players</code>显式地初始化为<code>0</code>就显得多余了。所以为了更清晰地表明我们使用了零值，应该写成这样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> players <span class="keyword">int</span></span><br></pre></td></tr></table></figure>
<p>那第二条语句呢？我们不能忽视类型写成：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> things = <span class="literal">nil</span></span><br></pre></td></tr></table></figure>
<p>因为<code>nil</code>根本就没有类型<a href="https://talks.golang.org/2014/names.slide#4" target="_blank" rel="noopener">^2</a>。相反，我们有一个选择，我们是否希望切片的零值？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> things []Thing</span><br></pre></td></tr></table></figure>
<p>或者我们是否希望创建一个没有元素的切片？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> things = <span class="built_in">make</span>([]Thing, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>如果我们想要的是后者，这不是个切片类型的零值，那么我们应该使用短声明语法让阅读者很清楚地明白我们的选择：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">things := <span class="built_in">make</span>([]Thing, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>这告诉了读者我们显式地初始化了<code>things</code>。</p>
<p>再来看看第三个声明：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> thing = <span class="built_in">new</span>(Thing)</span><br></pre></td></tr></table></figure>
<p>这既显式地初始化了变量，也引入了 Go 程序员不喜欢而且很不常用的<code>new</code>关键字。如果我们遵循短命名语法的建议，那么这句将变成：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thing := <span class="built_in">new</span>(Thing)</span><br></pre></td></tr></table></figure>
<p>这很清楚地表明，<code>thing</code>被显式地初始化为<code>new(Thing)</code>的结果——一个指向<code>Thing</code>的指针——但仍然保留了我们不常用的<code>new</code>。我们可以通过使用<strong>紧凑结构初始化的形式</strong>来解决这个问题，</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thing := &amp;Thing&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>这和<code>new(Thing)</code>做了同样的事——也因此很多 Go 程序员对这种重复感觉不安。不过，这一句仍然意味着我们为<code>thing</code>明确地初始化了一个<code>Thing{}</code>的指针——一个<code>Thing</code>的零值。</p>
<p>在这里，我们应该意识到，<code>thing</code>被初始化为了零值，并且将它的指针地址传递给了<code>json.Unmarshall</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> thing Thing</span><br><span class="line">json.Unmarshall(reader, &amp;thing)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：当然，对于任何经验法则都有例外。比如，有些变量之间很相关，那么与其写成这样：<br>var min int<br>max := 1000<br>不如写成这样更具可读性：<br><code>min, max := 0, 1000</code></p>
</blockquote>
<p>综上所述：</p>
<ul>
<li>只声明，不初始化时，使用<code>var</code>。</li>
<li>既声明，也显式地初始化时，使用<code>:=</code>。</li>
</ul>
<blockquote>
<p>小窍门：<strong>使得机巧的声明更加显而易见。</strong><br>当某件事本身很复杂时，<strong>应当</strong>使它看起来就复杂。<br><code>var length uint32 = 0x80</code><br>这里的<code>length</code>可能和一个需要有特定数字类型的库一起使用，并且<code>length</code>被很明确地指定为<code>uint32</code>类型而不只是短声明形式：<br><code>length := uint32(0x80)</code><br>在第一个例子中，我故意违反了使用<code>var</code>声明形式和显式初始化程序的规则。这个和我惯常形式不同的决定，可以让读者意识到这里需要注意。</p>
</blockquote>
<h2 id="成为团队合作者"><a href="#成为团队合作者" class="headerlink" title="成为团队合作者"></a>成为团队合作者</h2><p>我谈到了软件工程的目标，即生成可读，可维护的代码。而您的大部分职业生涯参与的项目可能您都不是唯一的作者。在这种情况下我的建议是遵守团队的风格。</p>
<p>在文件中间改变编码风格是不适合的。同样，即使您不喜欢，可维护性也比您的个人喜好有价值得多。我的原则是：如果满足<code>gofmt</code>，那么通常就不值得再进行代码风格审查了。</p>
<blockquote>
<p>小窍门：如果您要横跨整个代码库进行重命名，那么不要在其中混入其他的修改。如果其他人正在使用 git bisect，他们一定不愿意从几千行代码的重命名中“跋山涉水”地去寻找您别的修改。</p>
</blockquote>
<h1 id="代码注释"><a href="#代码注释" class="headerlink" title="代码注释"></a>代码注释</h1><p>在我们进行下一个更大的主题之前，我想先花几分钟说说注释的事。</p>
<blockquote>
<p>Good code has lots of comments, bad code requires lots of comments. — Dave Thomas and Andrew Hunt, The Pragmatic Programmer<br>好的代码中附带有大量的注释，坏的代码缺少大量的注释。</p>
</blockquote>
<p>代码注释对 Go 程序的可读性极为重要。一个注释应该做到如下三个方面的至少一个：</p>
<ol>
<li>注释应该解释“做什么”。</li>
<li>注释应该解释“怎么做的”。</li>
<li>注释应该解释“为什么这么做”。</li>
</ol>
<p>第一种形式适合公开的符号：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Open opens the named file for reading.</span></span><br><span class="line"><span class="comment">// If successful, methods on the returned file can be used for reading.</span></span><br></pre></td></tr></table></figure>
<p>第二种形式适合方法内的注释：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// queue all dependant actions</span></span><br><span class="line"><span class="keyword">var</span> results []<span class="keyword">chan</span> error</span><br><span class="line"><span class="keyword">for</span> _, dep := <span class="keyword">range</span> a.Deps &#123;</span><br><span class="line">        results = <span class="built_in">append</span>(results, execute(seen, dep))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三种形式，“为什么这么做”，这是独一无二的，无法被前两种取代，也无法取代前两种。第三种形式的注释用于解释更多的状况，而这些状况往往难以脱离上下文，否则将没有意义，这些注释就是用来阐述上下文的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> &amp;v2.Cluster_CommonLbConfig&#123;</span><br><span class="line">  <span class="comment">// Disable HealthyPanicThreshold</span></span><br><span class="line">  HealthyPanicThreshold: &amp;envoy_type.Percent&#123;</span><br><span class="line">    Value: <span class="number">0</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，很难立即弄清楚把<code>HealthyPanicThreshold</code>的百分比设置为零会产生什么影响。注释就用来明确将值设置为<code>0</code>实际上是禁用了<code>panic</code>阈值的这种行为。</p>
<h2 id="变量和常量上的注释应当描述它的内容，而非目的"><a href="#变量和常量上的注释应当描述它的内容，而非目的" class="headerlink" title="变量和常量上的注释应当描述它的内容，而非目的"></a>变量和常量上的注释应当描述它的内容，而非目的</h2><p>我之前谈过，变量或常量的名称应描述其目的。向变量或常量添加注释时，应该描述变量的<strong>内容</strong>，而不是定义它的<strong>目的</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> randomNumber = <span class="number">6</span> <span class="comment">// determined from an unbiased die</span></span><br></pre></td></tr></table></figure>
<p>这个示例的注释描述了“为什么”<code>randomNumber</code>被赋值为 6，也说明了 6 这个值是从何而来的。但它没有描述<code>randomNumber</code>会被用到什么地方。下面是更多的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    StatusContinue           = <span class="number">100</span> <span class="comment">// RFC 7231, 6.2.1</span></span><br><span class="line">    StatusSwitchingProtocols = <span class="number">101</span> <span class="comment">// RFC 7231, 6.2.2</span></span><br><span class="line">    StatusProcessing         = <span class="number">102</span> <span class="comment">// RFC 2518, 10.1</span></span><br><span class="line"></span><br><span class="line">    StatusOK                 = <span class="number">200</span> <span class="comment">// RFC 7231, 6.3.1</span></span><br></pre></td></tr></table></figure>
<p>如在 RFC 7231 的第 6.2.1 节中定义的那样，在 HTTP 语境中 100 被当做<code>StatusContinue</code>。</p>
<blockquote>
<p>小窍门：对于那些没有初始值的变量，注释应当描述谁将负责初始化它们<br>// sizeCalculationDisabled indicates whether it is safe<br>// to calculate Types’ widths and alignments. See dowidth.<br>var sizeCalculationDisabled bool<br>这里，通过注释让读者清楚函数<code>dowidth</code>在负责维护<code>sizeCalculationDisabled</code>的状态。</p>
</blockquote>
<blockquote>
<p>小窍门：<strong>隐藏一目了然的东西</strong><br>Kate Gregory 提到一点<a href="https://www.infoq.com/articles/API-Design-Joshua-Bloch" target="_blank" rel="noopener">^3</a>，有时一个好的命名，可以省略不必要的注释。<br>// registry of SQL drivers<br>var registry = make(map[string]*sql.Driver)<br>注释是源码作者加的，因为<code>registry</code>没能解释清楚定义它的目的——它是个注册表，但是什么的注册表？<br>通过重命名变量名为<code>sqlDrivers</code>，现在我们很清楚这个变量的目的是存储 SQL 驱动。<br>var sqlDrivers = make(map[string]*sql.Driver)<br>现在注释已经多余了，可以移除。</p>
</blockquote>
<h2 id="总是为公开符号写文档说明"><a href="#总是为公开符号写文档说明" class="headerlink" title="总是为公开符号写文档说明"></a>总是为公开符号写文档说明</h2><p>因为 godoc 将作为您的包的文档，您应该总是为每个公开的符号写好注释说明——包括变量、常量、函数和方法——所有定义在您包内的公开符号。</p>
<p>这里是 Go 风格指南的两条规则：</p>
<ul>
<li>任何既不明显也不简短的公共功能必须加以注释。</li>
<li>无论长度或复杂程度如何，都必须对库中的任何函数进行注释。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ioutil</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReadAll reads from r until an error or EOF and returns the data it read.</span></span><br><span class="line"><span class="comment">// A successful call returns err == nil, not err == EOF. Because ReadAll is</span></span><br><span class="line"><span class="comment">// defined to read from src until EOF, it does not treat an EOF from Read</span></span><br><span class="line"><span class="comment">// as an error to be reported.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadAll</span><span class="params">(r io.Reader)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span></span><br></pre></td></tr></table></figure>
<p>对这个规则有一个例外：您不需要为实现接口的方法进行文档说明，特别是不要这样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Read implements the io.Reader interface</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *FileReader)</span> <span class="title">Read</span><span class="params">(buf []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span></span><br></pre></td></tr></table></figure>
<p>这个注释等于说明都没说，它没有告诉您这个方法做了什么，实际上更糟的是，它让您去找别的地方的文档。在这种情况我建议将注释整个去掉。</p>
<p>这里有一个来自<code>io</code>这个包的示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LimitReader returns a Reader that reads from r</span></span><br><span class="line"><span class="comment">// but stops with EOF after n bytes.</span></span><br><span class="line"><span class="comment">// The underlying implementation is a *LimitedReader.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LimitReader</span><span class="params">(r Reader, n <span class="keyword">int64</span>)</span> <span class="title">Reader</span></span> &#123; <span class="keyword">return</span> &amp;LimitedReader&#123;r, n&#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A LimitedReader reads from R but limits the amount of</span></span><br><span class="line"><span class="comment">// data returned to just N bytes. Each call to Read</span></span><br><span class="line"><span class="comment">// updates N to reflect the new amount remaining.</span></span><br><span class="line"><span class="comment">// Read returns EOF when N &lt;= 0 or when the underlying R returns EOF.</span></span><br><span class="line"><span class="keyword">type</span> LimitedReader <span class="keyword">struct</span> &#123;</span><br><span class="line">  R Reader <span class="comment">// underlying reader</span></span><br><span class="line">  N <span class="keyword">int64</span>  <span class="comment">// max bytes remaining</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *LimitedReader)</span> <span class="title">Read</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> l.N &lt;= <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>, EOF</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">int64</span>(<span class="built_in">len</span>(p)) &gt; l.N &#123;</span><br><span class="line">    p = p[<span class="number">0</span>:l.N]</span><br><span class="line">  &#125;</span><br><span class="line">  n, err = l.R.Read(p)</span><br><span class="line">  l.N -= <span class="keyword">int64</span>(n)</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，<code>LimitedReader</code>的声明紧接在使用它的函数之后，并且<code>LimitedReader.Read</code>又紧接着定义在<code>LimitedReader</code>之后，即便<code>LimitedReader.Read</code>本身没有文档注释，那和很清楚它是<code>io.Reader</code>的一种实现。</p>
<blockquote>
<p>小窍门：在您编写函数之前先写描述这个函数的注释，如果您发现注释很难写，那就表明您正准备写的这段代码一定难以理解。</p>
</blockquote>
<h3 id="不要为坏的代码写注释，重写它"><a href="#不要为坏的代码写注释，重写它" class="headerlink" title="不要为坏的代码写注释，重写它"></a>不要为坏的代码写注释，重写它</h3><blockquote>
<p>Don’t comment bad code — rewrite it — Brian Kernighan<br>不要为坏的代码写注释——重写它</p>
</blockquote>
<p>为粗制滥造的代码片段着重写注释是不够的，如果您遭遇到一段这样的注释，您应该发起一个问题（issue）从而记得后续重构它。技术债务只要不是过多就没有关系。</p>
<p>在标准库的惯例是，批注一个 TODO 风格的注释，说明是谁发现了坏代码。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TODO(dfc) this is O(N^2), find a faster way to do this.</span></span><br></pre></td></tr></table></figure>
<p>注释中的姓名并不意味着承诺去修复问题，但在解决问题时，他可能是最合适的人选。其他批注内容一般还有日期或者问题编号。</p>
<h3 id="与其为一大段代码写注释，不如重构它"><a href="#与其为一大段代码写注释，不如重构它" class="headerlink" title="与其为一大段代码写注释，不如重构它"></a>与其为一大段代码写注释，不如重构它</h3><blockquote>
<p>Good code is its own best documentation. As you’re about to add a comment, ask yourself, ‘How can I improve the code so that this comment isn’t needed?’ Improve the code and then document it to make it even clearer. — Steve McConnell<br>好的代码即为最好的文档。在您准备添加一行注释时，问自己，“我要如何改进这段代码从而使它不需要注释？”优化代码，然后注释它使之更清晰。</p>
</blockquote>
<p>函数应该只做一件事。如果您发现一段代码因为与函数的其他部分不相关因而需要注释时，考虑将这段代码拆分为独立的函数。</p>
<p>除了更容易理解之外，较小的函数更容易单独测试，现在您将不相关的代码隔离拆分到不同的函数中，估计只有函数名才是唯一需要的文档注释了。</p>
<h1 id="包的设计"><a href="#包的设计" class="headerlink" title="包的设计"></a>包的设计</h1><blockquote>
<p>Write shy code - modules that don’t reveal anything unnecessary to other modules and that don’t rely on other modules’ implementations. — Dave Thomas<br>编写内敛的代码——模块不向外部透露任何不必要的信息，也不依赖外部模块的实现。</p>
</blockquote>
<p>每个 Go Package 事实上自身都是一个小的 Go 程序。正如函数或方法的实现对其调用者不重要一样，构成公开 API 的函数、方法、类型的实现——其行为——对调用者也不重要。</p>
<p>一个好的 Go Package 应该致力于较低的源码级耦合，这样，随着项目的增长，对一个包的更改不会级联影响其他代码库。那些“世界末日”似的重构让代码的更新优化变得极其困难，也让工作在这样的代码库上的开发者的生产效率极度地受限。</p>
<p>在这一节中我会来谈一谈包的设计，包括包的命名、类型的命名，以及编写方法和函数的一些小技巧。</p>
<h2 id="一个好的包从它的名称开始"><a href="#一个好的包从它的名称开始" class="headerlink" title="一个好的包从它的名称开始"></a>一个好的包从它的名称开始</h2><p>编写一个好的 Go 程序包从命名开始。好好思考您的软件包的名字，仅用一个词来描述它是什么。（Austin Luo：就如同“电梯游说”一样，您只能在极短的时间极少的话语的情况下描述您要表达的东西。）</p>
<p>正如我在上一节讲变量命名一样，包的名称也同样非常重要。以我的经验来看，我们应当思考的不是“我在这个包里应当放哪些类型”，而是“包提供的服务都应该做什么”。通常这个问题的答案不应该是“这个包提供了某某类型”，而是“这个包让您可以进行 HTTP 通信”。</p>
<blockquote>
<p>小窍门：以包“提供”的东西来命名，而不是以“包含”的东西来命名。</p>
</blockquote>
<h3 id="好的包名应该是唯一的"><a href="#好的包名应该是唯一的" class="headerlink" title="好的包名应该是唯一的"></a>好的包名应该是唯一的</h3><p>在您的项目里，每个包名都应该是唯一的。这个建议很容易理解，也很容易遵守。包的命名应该源于它的目的——如果您发现有两个包需要取相同的名字，那可能是下面两种情况：</p>
<ul>
<li>包的名称太通用了。</li>
<li>和另外一个类似名称的包重复了。在这种情况下，您应该重新评审设计或者直接将这两个包合并。</li>
</ul>
<h2 id="避免将包命名为base、common、util"><a href="#避免将包命名为base、common、util" class="headerlink" title="避免将包命名为base、common、util"></a>避免将包命名为<code>base</code>、<code>common</code>、<code>util</code></h2><p>一个低劣的名称通常是“utility”。这些通常是随着时间推移沉淀下来的通用帮助类或者工具代码。这种包里通常混合有各种不相关的功能，并且因为其通用性，以至于难以准确地描述这个包都提供了些什么。这通常导致包名来源于这个包“包含”的东西——一堆工具。</p>
<p>像<code>utils</code>或<code>helpers</code>这样的名称，通常在一些大型项目中找到，这些项目中已经开发了较深的层次结构，并且希望在共享这些帮助类函数时，避免循环导入。虽然打散这些工具函数到新的包也能打破循环导入，但是因为其本身是源于项目的设计问题，包名称并未反映其目的，因此打散它也仅仅只起到了打破导入循环的作用而已。</p>
<p>针对优化<code>utils</code>或<code>helpers</code>这种包名，我的建议是分析它们是在哪里被使用，并且是否有可能把相关函数挪到调用者所在的包。即便这可能导致一些重复的帮助类代码，但这也比在两个包之间引入一个导入依赖来的更好。</p>
<blockquote>
<p>[A little] duplication is far cheaper than the wrong abstraction. — Sandy Metz<br>（一点点的）重复远比错误的抽象更值得。</p>
</blockquote>
<p>在多个地方使用工具类方法的情况下，优先选择多个包（的设计），每个包专注于一个单独的方面，而不是整个包。（Austin Luo：Separation Of Concerns。）</p>
<blockquote>
<p>小窍门：使用复数形式命名工具包。比如<code>strings</code>是字符串的处理工具。</p>
</blockquote>
<p>像<code>base</code>或<code>common</code>这样的名称，常用于一个通用的功能被分为两个或多个实现的情况，或者一些用于客户端、服务端程序，并且被重构为单独通用类型的包。我认为解决这个问题的方法是减少包的数量，把客户端、服务端的通用代码合并到一个统一包里。</p>
<p>具体例子，<code>net/http</code>包总并没有<code>client</code>和<code>server</code>这两个子包，取而代之的是只有两个名为<code>client.go</code>和<code>server.go</code>的文件，每个文件处理各自的类型，以及一个<code>transport.go</code>文件用于公共消息传输的代码。</p>
<blockquote>
<p>小窍门：<strong>标识符的名称包括其包的名称</strong><br>牢记标识符的名称包含其所在包的名称，这一点很重要</p>
<ul>
<li><code>net/http</code>包中的<code>Get</code>函数，在其他包引用时变成了<code>http.Get</code>。</li>
<li><code>strings</code>包中的<code>Reader</code>类型，在其他包导入后变成了<code>strings.Reader</code>。</li>
<li><code>net</code>包中的<code>Error</code>接口很明确地与网络错误相关。</li>
</ul>
</blockquote>
<h2 id="快速返回，而不是深层嵌套"><a href="#快速返回，而不是深层嵌套" class="headerlink" title="快速返回，而不是深层嵌套"></a>快速返回，而不是深层嵌套</h2><p>正如 Go 并不使用异常来控制执行流程，也不需要深度缩进代码只为了在顶层结构添加一个<code>try...catch...</code>块。与把成功执行的路径向右侧一层一层深度嵌套相比，Go 风格的代码是随着函数的执行，成功路径往屏幕下方移动。我的朋友 Mat Ryer 称这种方式为“视线”编码。<a href="https://medium.com/@matryer/line-of-sight-in-code-186dd7cdea88" target="_blank" rel="noopener">^4</a></p>
<p>这是通过“保护条款”来实现的（Austin Luo: 类似我们常说的防御式编程）：条件代码块在进入函数时立即断言前置条件。这里是<code>bytes</code>包里的一个示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Buffer)</span> <span class="title">UnreadRune</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> b.lastRead &lt;= opInvalid &#123;</span><br><span class="line">    <span class="keyword">return</span> errors.New(<span class="string">"bytes.Buffer: UnreadRune: previous operation was not a successful ReadRune"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> b.off &gt;= <span class="keyword">int</span>(b.lastRead) &#123;</span><br><span class="line">    b.off -= <span class="keyword">int</span>(b.lastRead)</span><br><span class="line">  &#125;</span><br><span class="line">  b.lastRead = opInvalid</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一旦进入<code>UnreadRune</code>，就会检查<code>b.lastRead</code>，如果之前的操作不是<code>ReadRune</code>就会立即返回错误。从这里开始，函数执行下去的其余部分，我们就能明确肯定<code>b.lastRead</code>比<code>opInvalid</code>大了。</p>
<p>与没有使用“保护条款”的相同功能代码对比看看：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Buffer)</span> <span class="title">UnreadRune</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> b.lastRead &gt; opInvalid &#123;</span><br><span class="line">    <span class="keyword">if</span> b.off &gt;= <span class="keyword">int</span>(b.lastRead) &#123;</span><br><span class="line">      b.off -= <span class="keyword">int</span>(b.lastRead)</span><br><span class="line">    &#125;</span><br><span class="line">    b.lastRead = opInvalid</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> errors.New(<span class="string">"bytes.Buffer: UnreadRune: previous operation was not a successful ReadRune"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最通常的、成功的情况，被缩进到了第一个<code>if</code>条件中了。并且成功的退出条件 <code>return nil</code>，需要非常小心地与闭口括号（}）对应。接下来，最后一行代码返回了一个错误，并且我们需要回退跟踪到函数的开口括号（{）才知道执行控制流什么时候到达了这里。</p>
<p>对于读者和维护程序员来说，这更容易出错，因此 Go 更喜欢使用“保护条款”并尽早返回错误。</p>
<h2 id="让零值变得有意义"><a href="#让零值变得有意义" class="headerlink" title="让零值变得有意义"></a>让零值变得有意义</h2><p>假设没有明确提供显示初始化器，每个变量声明之后都会被自动初始化为零内存对应的值，这就是<strong>零值</strong>。零值与其类型有关：数值类型为<code>0</code>，指针为<code>nil</code>，切片、映射、管道等也同样（为<code>nil</code>）。</p>
<p>始终将值设置为已知默认值，对于程序的安全性和正确性非常重要，并且可以使 Go 程序更简单，更紧凑。这就是 Go 程序员在说“给您的结构一个有用的零值”时所表达的意思。</p>
<p>我们来看<code>sync.Mutex</code>这类型。它有两个未导出的整数型字段，表示互斥锁的内部状态。由于零值，无论何时一个<code>sync.Mutex</code>类型变量被声明后，这些字段都将被设置为<code>0</code>。<code>sync.Mutex</code>类被故意地编码为这样，使得它无需被显式初始化即可使得零值有意义。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyInt <span class="keyword">struct</span> &#123;</span><br><span class="line">  mu  sync.Mutex</span><br><span class="line">  val <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> i MyInt</span><br><span class="line"></span><br><span class="line">  <span class="comment">// i.mu is usable without explicit initialisation.</span></span><br><span class="line">  i.mu.Lock()</span><br><span class="line">  i.val++</span><br><span class="line">  i.mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Austin Luo：原文为“useful”，我在此译为“有意义”而不是“有用”，意在强调其零值是符合业务的、符合逻辑的，并且也是初始的、默认的，而不是“不用管它，让它为零好了”。<br>这与变量的命名也息息相关，比如：<br><code>isCacheEnabled bool</code> // 缓存是否被启用<br><code>isCacheDisabled bool</code> // 缓存是否被禁用<br>对于上述两个变量，看起来都差不多，随意定义其中一个即可，唯一的差别只是一个表示启用一个表示禁用而已。但是结合考虑“业务要求默认启用缓存”和“bool 的零值为 false”，那么显然我们应该定义<code>isCacheDisabled bool</code>而不是前者。一方面，调用者不显式赋值时<strong>默认零值</strong>为<code>false</code>，另一方面值为<code>false</code>时表达的含义与<strong>业务要求默认启用缓存</strong>一致。<br>这才使得零值真正地<strong>有意义</strong>，正如示例中注释的那行<code>i.mu</code>一样，不显示初始化其代表的是默认锁是可用的。</p>
</blockquote>
<p>另一个有意义零值的类型示例是<code>bytes.Buffer</code>。您可以无需显式初始化地声明<code>bytes.Buffer</code>然后立即开始向它写入数据。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> b bytes.Buffer</span><br><span class="line">  b.WriteString(<span class="string">"Hello, world!\n"</span>)</span><br><span class="line">  io.Copy(os.Stdout, &amp;b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>切片的一个有用性质是它的零值为<code>nil</code>，我们只需要去看看切片的运行时定义即可理解它的合理性：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">  array *[...]T <span class="comment">// pointer to the underlying array</span></span><br><span class="line">  <span class="built_in">len</span>   <span class="keyword">int</span></span><br><span class="line">  <span class="built_in">cap</span>   <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此结构的零值将暗示<code>len</code>和<code>cap</code>的值为<code>0</code>，并且指向内存的指针<code>array</code>，保存切片背后数组的内容，其值也为<code>nil</code>。这意味着您不需要显式<code>make</code>切片，您只需声明它即可。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// s := make([]string, 0)</span></span><br><span class="line">  <span class="comment">// s := []string&#123;&#125;</span></span><br><span class="line">  <span class="keyword">var</span> s []<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">  s = <span class="built_in">append</span>(s, <span class="string">"Hello"</span>)</span><br><span class="line">  s = <span class="built_in">append</span>(s, <span class="string">"world"</span>)</span><br><span class="line">  fmt.Println(strings.Join(s, <span class="string">" "</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>NOTE：<code>var s []string</code>看起来和上面被注释掉的两行很像，但又不完全相同。要判断值为<code>nil</code>的切片和长度为零的切片的区别是可以办到的，下面的代码将输出<code>false</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;   <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<pre><code>var s1 = []string{}
var s2 []string
fmt.Println(reflect.DeepEqual(s1, s2))
</code></pre><p>}</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">一个意外但是有用的惊喜是未初始化的指针——`<span class="literal">nil</span>`指针，您可以在`<span class="literal">nil</span>`值的类型上调用方法，这可以简单地用于提供默认值。</span><br><span class="line"></span><br><span class="line">```go</span><br><span class="line">type <span class="type">Config</span> <span class="class"><span class="keyword">struct</span> </span>&#123;</span><br><span class="line">path string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(<span class="built_in">c</span> *Config)</span></span> <span class="type">Path</span>() string &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">c</span> == <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"/usr/home"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">c</span>.path</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> c1 *<span class="type">Config</span></span><br><span class="line"><span class="keyword">var</span> c2 = &amp;<span class="type">Config</span>&#123;</span><br><span class="line">  path: <span class="string">"/export"</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.<span class="type">Println</span>(c1.<span class="type">Path</span>(), c2.<span class="type">Path</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="避免包级别的状态"><a href="#避免包级别的状态" class="headerlink" title="避免包级别的状态"></a>避免包级别的状态</h2><p>编写可维护的程序的一个关键方面是松耦合——更改一个包，应该把对没有直接依赖它的包的影响降到最低。</p>
<p>在 Go 中有两种很好的方法可以实现松散耦合：</p>
<ul>
<li>使用接口来描述函数或方法所需的行为。</li>
<li>避免使用全局状态。</li>
</ul>
<p>在 Go 中，我们可以在函数或方法范围内声明变量，也可以在包的范围内声明变量。当变量是公开的，标识符首字母为大写，那么其范围实际上是整个程序——任何包都可以在任何时候观察到它的类型和存储的内容。</p>
<p>可变的全局状态在程序的独立部分之间引入了紧耦合，因为全局变量对于程序中的每个函数都是隐匿的参数！如果全局变量的类型变化了，那么任何依赖该变量的函数将会被打破。程序其他任何部分对变量值的修改，都将导致依赖该变量状态的函数被打破。</p>
<blockquote>
<p>Austin Luo：全局变量对每个函数都是可见的，但开发者可能意识不到全局变量的存在（即隐匿的参数），即使意识到并使用了全局变量，也可能意识不到该变量可能在别处被修改，导致全局变量的使用不可靠，依赖该变量状态（值）的函数被打破。</p>
</blockquote>
<p>如果您想减少全局变量带来的耦合，那么：</p>
<ol>
<li>将相关变量作为字段移动到需要它们的结构上。</li>
<li>使用接口来减少行为与该行为的实现之间的耦合。</li>
</ol>
<h1 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h1><p>让我们来看看多个包合并在一起组成项目的情况。通常这应该是一个单独的 git 仓库，但在将来， Go 开发者将交替使用 <code>module</code> 和 <code>project</code>。</p>
<p>和包一样，每个项目也应该有一个清晰的目的。如果您的项目是个库，那么它应该只提供一个东西，比如 XML 解析，或者日志记录。您应该避免将多个不同的目的混杂在同一个项目中，这有助于避免<code>common</code>库的出现。</p>
<blockquote>
<p>小窍门：根据我的经验，<code>common</code> 库与其最大的消费者（使用者）紧密相连，这使得在不锁定步骤的情况下单独升级<code>common</code>或者消费者以进行升级或者修复变得很困难，从而带来很多不相关的更改和 API 破坏。</p>
</blockquote>
<p>如果您的项目是一个应用程序，比如您的 Web 应用，Kubernetes 控制器等等，那么在您的项目中可能有一个或多个 <code>main</code> 包。比如，我维护的那个 Kubernetes 控制器里有一个单独的 <code>cmd/contour</code> 包，用来提供到 Kubernetes 集群的服务部署，以及用于调试的客户端。</p>
<h2 id="考虑更少、更大的包"><a href="#考虑更少、更大的包" class="headerlink" title="考虑更少、更大的包"></a>考虑更少、更大的包</h2><p>对于从其他语言过渡到 Go 的程序员来说，我倾向于在代码审查中提到的一件事是，他们倾向于过度使用包。</p>
<p>Go 没有提供建立可见性的详细方法：比如 Java 的 <code>public</code>、<code>protected</code>、<code>private</code>和隐式 <code>default</code> 访问修饰符，也没有相当于 C++ 的<code>friend</code>类的概念。</p>
<p>在 Go 中我们只有两种访问修饰符，公开和私有，这由标识符首字母的大小写决定。如果标识符是公开的，命名首字母就是大写的，则这个标识符可以被其他任何 Go 包引用。</p>
<blockquote>
<p>注意：您可能听到有人说导出和非导出，那是公开和私有的同义词。</p>
</blockquote>
<p>鉴于对包里的符号可见性控制手段的有限，Go 程序员要怎么做才能避免创建过于复杂的包层次结构呢？</p>
<blockquote>
<p>小窍门：除 <code>cmd/</code> 和 <code>internal/</code> 之外，每个包都应该包含一些源代码。</p>
</blockquote>
<p>我反复建议的是偏向更少、更大的包。您的默认选项并不是创建新的包，那将导致为了创建宽而浅的 API 平面时您不得不公开太多的类型。</p>
<p>接下来的几节让我们更详细地探讨这些建议。</p>
<blockquote>
<p>小窍门：<strong>来自 Java？</strong><br>如果您有开发 Java 或 C# 的背景，考虑这样的经验规则：一个 Java 包等效于一个独立的 <code>.go</code> 源文件；一个 Go 包等效于整个 Maven 模块或 .NET 程序集。</p>
</blockquote>
<h3 id="通过-import-语句将代码整理到多个文件中"><a href="#通过-import-语句将代码整理到多个文件中" class="headerlink" title="通过 import 语句将代码整理到多个文件中"></a>通过 import 语句将代码整理到多个文件中</h3><p>如果您根据包提供给调用者的功能来整理包，那么在 Go 包里整理源文件是不是也应该按相同的方式？您如何知道什么时候您应该将一个 <code>.go</code> 文件拆分成多个文件？您如何知道是不是过分拆分，而应当考虑整合多个 <code>.go</code> 文件？</p>
<p>这里是我用到的一些经验规则：</p>
<ul>
<li>从单一的 <code>.go</code> 文件开始，并且使用与包相同的名字。比如包 <code>http</code> 的第一个文件应该是 <code>http.go</code>，并且放到名为 <code>http</code> 的文件夹中。</li>
<li>随着包的逐渐增长，您可以根据职责拆分不同的部分到不同的文件。例如，将 <code>Request</code> 和 <code>Response</code> 类型拆分到 <code>message.go</code> 中，将 <code>Client</code> 类型拆分到 <code>client.go</code> 中，将 <code>Server</code> 类型拆分到 <code>server.go</code> 中。</li>
<li>如果您发现您的文件具有很相似的 import 声明时，考虑合并它们，否则确定两者的具体差异并优化重构它们。</li>
<li>不同的文件应该负责包的不同区域。<code>messages.go</code> 可能负责网络相关的 HTTP 请求和响应编组，<code>http.go</code> 可能包含低级网络处理逻辑，<code>client.go</code> 和 <code>server.go</code> 实现 HTTP 请求创建或路由的业务逻辑，等等。</li>
</ul>
<blockquote>
<p>小窍门：源文件名应当考虑名词。</p>
</blockquote>
<blockquote>
<p>注意：Go 编译器并行编译各个包。在包中，Go 编译器并行地编译各个函数（方法在 Go 中只是花哨的函数）。修改包源码中代码的排列分布不影响编译时间。</p>
</blockquote>
<h3 id="内部测试优于外部测试"><a href="#内部测试优于外部测试" class="headerlink" title="内部测试优于外部测试"></a>内部测试优于外部测试</h3><p>Go 工具集允许您在两处编写包的测试。假设您的包名是 <code>http2</code>，您可以使用 <code>package http2</code> 声明并编写一个 <code>http2_test.go</code> 文件，这样做将会把 <code>http2_test.go</code> 中的代码当成 http2 包的一部分编译进去。这通常称为<strong>内部</strong>测试。</p>
<p>Go 工具集同样支持一个以 test 结尾的特定声明的包，例如 <code>package http_test</code>，即使这些测试代码不会被视为正式代码一样编译到正式的包里，并且他们有自己独立的包名，也允许您的测试文件和源码文件一样放置在一起。这允许让您像在外部另外一个包里调用一样编写测试用例，这我们称之为<strong>外部</strong>测试。</p>
<p>在编写单元测试时我推荐使用内部测试。这让您可以直接测试每个函数或方法，避免外部测试的繁文缛节。</p>
<p>但是，您应该把 <code>Example</code> 测试函数放到外部测试中。这确保了在 godoc 中查看时，示例具有适当的包前缀，并且可以轻松地进行复制粘贴。</p>
<blockquote>
<p>小窍门：<strong>避免复杂的包层次结构，克制分类的渴望</strong><br>只有一个例外，这我们将在后面详述。对于 Go 工具集来讲，Go 包的层次结构是没有意义的。例如，<code>net/http</code> 并不是 <code>net</code> 的子或子包。<br>如果您创建了不包含任何 <code>.go</code> 文件的中间目录，则不适用此建议。</p>
</blockquote>
<h3 id="使用-internal-包收敛公开的-API-表面"><a href="#使用-internal-包收敛公开的-API-表面" class="headerlink" title="使用 internal 包收敛公开的 API 表面"></a>使用 <code>internal</code> 包收敛公开的 API 表面</h3><p>如果您的项目包含多个包，则可能有一些导出的函数——这些函数旨在供项目中的其他包使用，却又不打算成为项目的公共 API 的一部分。如果有这样的情况，则 go 工具集会识别一个特殊的文件夹名——非包名—— <code>internal/</code>，这用于放置那些对当前项目公开，但对其他项目私有的代码。</p>
<p>要创建这样的包，把代码放置于名为 <code>internal/</code> 的目录或子目录即可。 go 命令发现导入的包中包含 <code>internal</code> 路径，它就会校验执行导入的包是否位于以 <code>internal</code> 的父目录为根的目录树中。</p>
<p>例如，包 <code>.../a/b/c/internal/d/e/f</code> 只能被根目录树 <code>.../a/b/c</code> 中的代码导入，不能被 <code>.../a/b/g</code> 或者其他任何库中的代码导入。<a href="https://golang.org/doc/go1.4#internalpackages" target="_blank" rel="noopener">^5</a></p>
<h2 id="确保-main-包越小越好"><a href="#确保-main-包越小越好" class="headerlink" title="确保 main 包越小越好"></a>确保 main 包越小越好</h2><p><code>main</code> 函数和 <code>main</code> 包应当只做尽可能少的事情，因为 <code>main.main</code> 实际上是一个单例，整个应用程序都只允许一个 <code>main</code> 函数存在，包括单元测试。</p>
<p>由于 <code>main.main</code> 是一个单例，因此 <code>main.main</code> 的调用中有很多假定，而这些假定又只在 <code>main.main</code> 或 <code>main.init</code> 期间调用，并且只调用一次。这导致很难为 <code>main.main</code> 中的代码编写单元测试，因此您的目标应该是将您的业务逻辑从主函数中移出，最好是压根从主程序包中移出。</p>
<blockquote>
<p>Austin Luo：这里主要是讲，由于整个程序（包括单元测试在内）只允许存在一个 <code>main.main</code>，因此在 <code>main.main</code> 中编写过多的代码将导致这些代码很难被测试覆盖，因此应当将这些代码从 <code>main.main</code> 中——甚至从 <code>main</code> 包中——独立出来，以便能够写单元测试进行测试。（文中的“假定”是针对测试而言，“假定” main 中的代码可以正常运行。）</p>
</blockquote>
<blockquote>
<p>小窍门：<code>main</code> 应当解析标识，打开数据库连接，初始化日志模块等等，然后将具体的执行交给其他高级对象。</p>
</blockquote>
<h1 id="API-设计"><a href="#API-设计" class="headerlink" title="API 设计"></a>API 设计</h1><p>今天给出的最后一个设计建议是我认为最重要的一个。</p>
<p>到此为止我给出的所有建议，也仅仅是建议。这是我写 Go 程序时遵守的方式，但也并没有强制推行到代码评审中。</p>
<p>但是，在审查 API 时，我就不太宽容了。因为之前我所说的一切都可以在不破坏向后兼容性的情况下得到修正，他们大多只是实施细节而已。</p>
<p>但说到包的开放 API，在初始设计中投入大量精力是值得的，因为后续的更改将是破坏性的，特别是对于已经使用 API ​​ 的人来说。</p>
<h2 id="设计难以被误用的-API"><a href="#设计难以被误用的-API" class="headerlink" title="设计难以被误用的 API"></a>设计难以被误用的 API</h2><blockquote>
<p>APIs should be easy to use and hard to misuse. — Josh Bloch <a href="https://www.infoq.com/articles/API-Design-Joshua-Bloch" target="_blank" rel="noopener">^3</a><br>API 应当易用并且难以被误用</p>
</blockquote>
<p>如果您从这个演讲中获得任何收益，那就应该是 Josh Bloch 的这个建议。如果 API 很难用于简单的事情，那么 API 的每次调用都会很复杂。当 API 的实际调用很复杂时，它将不那么明显，更容易被忽视。</p>
<h3 id="警惕具有多个相同类型参数的函数"><a href="#警惕具有多个相同类型参数的函数" class="headerlink" title="警惕具有多个相同类型参数的函数"></a>警惕具有多个相同类型参数的函数</h3><p>一个看起来很简单，但实际很难正确使用的 API 的例子，就是具有两个及以上的相同类型参数的情况。让我们来对比如下两个函数签名：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Max</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">CopyFile</span><span class="params">(to, from <span class="keyword">string</span>)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>
<p>这两个函数有什么不同？很显然一个是返回两个数的最大数，另一个是复制文件，但这都不是重点。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Max(<span class="number">8</span>, <span class="number">10</span>) <span class="comment">// 10</span></span><br><span class="line">Max(<span class="number">10</span>, <span class="number">8</span>) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
<p><code>Max</code>是可交换的，参数的顺序无关紧要，8 和 10 比较无论如何都是 10 更大，不论是 8 与 10 比较，还是 10 与 8 比较。</p>
<p>但是，对于 CopyFile 就不具有这样的特性了：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CopyFile(<span class="string">"/tmp/backup"</span>, <span class="string">"presentation.md"</span>)</span><br><span class="line">CopyFile(<span class="string">"presentation.md"</span>, <span class="string">"/tmp/backup"</span>)</span><br></pre></td></tr></table></figure>
<p>哪条语句将 presentation.md 复制了一份，哪条语句又是用上周的版本覆盖了 presentation.md ？没有文档说明，您很难分辨。代码评审者在没有文档时也对您参数传入的顺序是否正确不得而知。</p>
<p>一个可行的解决方案是，引入一个帮助类，用来正确地调用 <code>CopyFile</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Source <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(src Source)</span> <span class="title">CopyTo</span><span class="params">(dest <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> CopyFile(dest, <span class="keyword">string</span>(src))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> from Source = <span class="string">"presentation.md"</span></span><br><span class="line">  from.CopyTo(<span class="string">"/tmp/backup"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样 <code>CopyFile</code> 就总是可以被正确地调用——这也可以通过单元测试确定，也可以被设置为私有，进一步降低了误用的可能性。</p>
<blockquote>
<p>小窍门：具有多个相同类型参数的 API 很难被正确使用。</p>
</blockquote>
<h2 id="针对默认用例设计-API"><a href="#针对默认用例设计-API" class="headerlink" title="针对默认用例设计 API"></a>针对默认用例设计 API</h2><p>几年前我做过一次关于使用功能选项<a href="https://commandcenter.blogspot.com/2014/01/self-referential-functions-and-design.html" target="_blank" rel="noopener">^7</a>使 API 在默认用例时更易用的报告<a href="https://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis" target="_blank" rel="noopener">^6</a>。</p>
<p>本演讲的主旨是您应该为常见用例设计 API。另一方面，您的 API 不应要求调用者提供那些他们不关心的参数。</p>
<h3 id="不鼓励使用-nil-作为参数"><a href="#不鼓励使用-nil-作为参数" class="headerlink" title="不鼓励使用 nil 作为参数"></a>不鼓励使用 <code>nil</code> 作为参数</h3><p>我讲述本章开宗明义时建议您不要强迫 API 的调用者在他们不关心这些参数意味着什么的情况下为您提供那些参数。当我说针对默认用例的设计 API 时，这就是我的意思。</p>
<p>这里有个来自 <code>net/http</code> 包的示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> http</span><br><span class="line"></span><br><span class="line"><span class="comment">// ListenAndServe listens on the TCP network address addr and then calls</span></span><br><span class="line"><span class="comment">// Serve with handler to handle requests on incoming connections.</span></span><br><span class="line"><span class="comment">// Accepted connections are configured to enable TCP keep-alives.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The handler is typically nil, in which case the DefaultServeMux is used.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// ListenAndServe always returns a non-nil error.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListenAndServe</span><span class="params">(addr <span class="keyword">string</span>, handler Handler)</span> <span class="title">error</span></span> &#123;</span><br></pre></td></tr></table></figure>
<p><code>ListenAndServe</code> 有两个参数，一个 TCP 地址用来监听传入连接，一个 <code>http.Handler</code> 用来处理传入的 HTTP 请求。<code>Serve</code> 允许第二个参数为 <code>nil</code>，并且注意，调用者通常都会传入 <code>nil</code> 用来表示他们希望使用 <code>http.DefaultServeMux</code> 作为隐式参数。</p>
<p>现在<code>Serve</code>的调用者就有两个方式来做同样的事情：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http.ListenAndServe(<span class="string">"0.0.0.0:8080"</span>, <span class="literal">nil</span>)</span><br><span class="line">http.ListenAndServe(<span class="string">"0.0.0.0:8080"</span>, http.DefaultServeMux)</span><br></pre></td></tr></table></figure>
<p>两个方式都做完全一样的事情。</p>
<p>这种 <code>nil</code> 的行为是病毒式的。在 <code>http</code> 包中同样有个 <code>http.Serve</code> 帮助类，您可以合理地想象 <code>ListenAndServe</code> 是这样建立的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListenAndServe</span><span class="params">(addr <span class="keyword">string</span>, handler Handler)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  l, err := net.Listen(<span class="string">"tcp"</span>, addr)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">defer</span> l.Close()</span><br><span class="line">  <span class="keyword">return</span> Serve(l, handler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为<code>ListenAndServe</code>允许调用者为第二个参数传递<code>nil</code>，所以<code>http.Serve</code>也支持这种行为。事实上，<code>http.Serve</code> 是“当 <code>handler</code> 为 <code>nil</code>，则使用 <code>DefaultServeMux</code>”这个逻辑的一个实现。允许其中一个参数传入 <code>nil</code> 可能导致调用者以为他们可以给两个参数都传入 <code>nil</code>（Austin Luo：调用者可能想，既然第二个参数有默认实现，那第一个参数可能也有），但像这样调用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.Serve(<span class="literal">nil</span>, <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>
<p>将导致一个丑陋的 panic 。</p>
<blockquote>
<p>小窍门：在函数签名中不要混用可为 <code>nil</code> 和不可为 <code>nil</code> 的参数。</p>
</blockquote>
<p><code>http.ListenAndServe</code> 的作者尝试在常规状况时让 API 的使用者更轻松，但可能反而导致这个包难于被安全地使用。</p>
<p>显示地指定 <code>DefaultServeMux</code> 或隐式地指定 <code>nil</code>，并没有在代码行数上带来不同。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> root = http.Dir(<span class="string">"/htdocs"</span>)</span><br><span class="line">http.Handle(<span class="string">"/"</span>, http.FileServer(root))</span><br><span class="line">http.ListenAndServe(<span class="string">"0.0.0.0:8080"</span>, <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>
<p>相较于</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> root = http.Dir(<span class="string">"/htdocs"</span>)</span><br><span class="line">http.Handle(<span class="string">"/"</span>, http.FileServer(root))</span><br><span class="line">http.ListenAndServe(<span class="string">"0.0.0.0:8080"</span>, http.DefaultServeMux)</span><br></pre></td></tr></table></figure>
<p>并且，仅仅为了节省一行代码，这样的混乱是值得的吗？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> root = http.Dir(<span class="string">"/htdocs"</span>)</span><br><span class="line">mux := http.NewServeMux()</span><br><span class="line">http.Handle(<span class="string">"/"</span>, http.FileServer(root))</span><br><span class="line">http.ListenAndServe(<span class="string">"0.0.0.0:8080"</span>, mux)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>小窍门：认真考虑帮助类将节省程序员的时间。清晰比多个选择好。</p>
</blockquote>
<blockquote>
<p>小窍门：<strong>避免公开只用于测试的参数</strong><br>避免公开导出仅在测试作用域上具有不同值的 API。相反，使用 Public 包装隐藏这些参数，使用在测试作用域的帮助类来设置测试范围中的属性。</p>
</blockquote>
<h3 id="首选可变参数（var-args）而非切片参数（-T）"><a href="#首选可变参数（var-args）而非切片参数（-T）" class="headerlink" title="首选可变参数（var args）而非切片参数（[]T）"></a>首选可变参数（var args）而非切片参数（[]T）</h3><p>编写一个处理切片的函数或方法是很常见的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ShutdownVMs</span><span class="params">(ids []<span class="keyword">string</span>)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>
<p>这仅仅是我举的一个例子，但在我工作中更加常见。像这样的签名的问题是，他们假设被调用时会有多个实体。但是，我发现很多时候这些类型的函数却只有一个参数，为了满足函数签名的要求，它必须在一个切片内“装箱”。（Austin Luo：如示例，函数定义时预期会有多个 id，但实际调用时往往只有一个 id，为了满足前面，必须构造一个切片，并把 id 装进去。）</p>
<p>此外，由于 <code>ids</code> 是个切片，您可以向函数传入一个空的切片甚至 <code>nil</code>，编译器也会允许。这就增加了更多的测试用例，因为您应当覆盖这些场景。</p>
<p>为构造一个这类型的 API 的例子，最近我重构了一条逻辑，如果一组参数中至少有一个非零则要求我设置一些额外的字段。这段逻辑看起来像这样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> svc.MaxConnections &gt; <span class="number">0</span> || svc.MaxPendingRequests &gt; <span class="number">0</span> || svc.MaxRequests &gt; <span class="number">0</span> || svc.MaxRetries &gt; <span class="number">0</span> &#123;</span><br><span class="line">  <span class="comment">// apply the non zero parameters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>鉴于 if 语句变得非常长，我想将这个校验放到单独的函数中，这是优化的结果：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// anyPostive indicates if any value is greater than zero.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">anyPositive</span><span class="params">(values ...<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> _, v := <span class="keyword">range</span> values &#123;</span><br><span class="line">    <span class="keyword">if</span> v &gt; <span class="number">0</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这使我能够向读者明确执行内部块的条件：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> anyPositive(svc.MaxConnections, svc.MaxPendingRequests, svc.MaxRequests, svc.MaxRetries) &#123;</span><br><span class="line">  <span class="comment">// apply the non zero parameters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但对于 <code>anyPositive</code> 还是有一个问题，有人可能会意外地像这样调用它：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> anyPositive（）&#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>在这种情况下<code>anyPositive</code>会返回<code>false</code>，因为它将不会执行迭代并立即返回<code>false</code>。这还不是世界上最糟糕的事情——（更糟糕的是）没有传入参数时这段代码的逻辑将会变成“<code>anyPositive</code>是否返回<code>true</code>？”。</p>
<p>然而，假如可以这样那就更好了：更改 <code>anyPositive</code> 的签名，使得强制调用者应该传递至少一个参数。我们可以像这样组合常规参数和可变参数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// anyPostive indicates if any value is greater than zero.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">anyPositive</span><span class="params">(first <span class="keyword">int</span>, rest ...<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> first &gt; <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> _, v := <span class="keyword">range</span> rest &#123;</span><br><span class="line">    <span class="keyword">if</span> v &gt; <span class="number">0</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在<code>anyPositive</code>的调用就不能少于一个参数了。</p>
<h2 id="让函数自身定义它所需的行为"><a href="#让函数自身定义它所需的行为" class="headerlink" title="让函数自身定义它所需的行为"></a>让函数自身定义它所需的行为</h2><p>假设我们有个将文档保存写入磁盘的工作任务。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Save writes the contents of doc to the file f.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Save</span><span class="params">(f *os.File, doc *Document)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>
<p>我可以这样描述这个函数，<code>Save</code>，它以一个 <code>*os.File</code> 作为目标来保存写入 <code>Document</code>。但这有一些问题。</p>
<p>签名 <code>Save</code> 排除了将数据写入网络位置的可能。假设网络存储成为后续的需求，可能不得不更改函数签名，从而影响其所有调用者。</p>
<p><code>Save</code> 也对测试不友好，因为这是直接对磁盘的文件进行操作。因此，为了验证其操作，测试用例不得不在文件被写入之后重新去读取写入的内容。而且我还必须确保 <code>f</code> 最终从临时位置被删除。</p>
<p>同时 <code>*os.File</code> 也定义了很多与 <code>Save</code> 无关的方法，比如读取目录，检查一个路径是否为符号链接等。如果 <code>Save</code> 函数的签名只描述 <code>*os.File</code> 的一部分就更好了。</p>
<p>我们可以怎么做呢？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Save writes the contents of doc to the supplied</span></span><br><span class="line"><span class="comment">// ReadWriterCloser.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Save</span><span class="params">(rwc io.ReadWriteCloser, doc *Document)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>
<p>使用 <code>io.ReadWriteCloser</code> 我们可以遵循<strong>接口隔离原则</strong>重新定义 <code>Save</code> ，从而获得一个更常规的文件操作接口。</p>
<p>有了这个改变，<code>io.ReadWriteCloser</code> 接口的任何实现都可以替代前文的 <code>*os.File</code>。</p>
<p>这使得 <code>Save</code> 的应用更加广泛，并且向 <code>Save</code> 的调用者澄清了哪些 <code>*os.File</code> 类型的方法与其操作相关。</p>
<p>并且，作为 <code>Save</code> 函数作者，我不再能调用 <code>*os.File</code> 其他那些不相关方法，它们都被 <code>io.ReadWriteCloser</code> 接口隐藏到了背后。</p>
<p>我们可以针对接口隔离原则谈得更深入些。</p>
<p>首先，如果 <code>Save</code> 遵循单一职责原则，它不太可能读取它刚刚编写的文件以校验其内容——这应该是另一段代码的责任。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Save writes the contents of doc to the supplied</span></span><br><span class="line"><span class="comment">// WriteCloser.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Save</span><span class="params">(wc io.WriteCloser, doc *Document)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>
<p>因此，我们可以将传递给 <code>Save</code> 的接口缩小到只是写和关闭两个方面。</p>
<p>其次，通过 <code>Save</code> 附带提供一种关闭其流的机制（Austin Luo：由于 <code>io.WriteCloser</code> 的存在，<code>Save</code> 隐含了关闭流的含义）。我们继承了这种机制，使其仍然看起来像一个文件，这就提出了在什么情况下 <code>wc</code> 会被关闭的问题。</p>
<p>可能 <code>Save</code> 会无条件地调用 <code>Close</code>，或者在成功的情况下才调用 <code>Close</code>。</p>
<p>这给 <code>Save</code> 的调用者带来一个问题，那就是希望在写入文档之后再向数据流写入其他数据时怎么办？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Save writes the contents of doc to the supplied</span></span><br><span class="line"><span class="comment">// Writer.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Save</span><span class="params">(w io.Writer, doc *Document)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>
<p>一个更好的解决方案是，重新定义 <code>Save</code>，只持有一个 <code>io.Writer</code>，将除了向数据流写入数据之外的其他所有职责都完全剥离出来。</p>
<p>通过在 <code>Save</code> 函数上遵循接口隔离原则，其结果是实际需求的最核心描述同时作为一个函数——它只需要一个可写的对象——并且是最通常的情况，我们现在可以使用 <code>Save</code> 来向任何 <code>io.Writer</code> 的实现保存数据。</p>
<h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><p>我已经做了好几场关于错误处理的演讲，在我的博客里也写了很多相关的内容，昨天的那一节我也讲了很多了，因此我不打算再赘述了。</p>
<ul>
<li><a href="https://dave.cheney.net/2014/12/24/inspecting-errors" target="_blank" rel="noopener">https://dave.cheney.net/2014/12/24/inspecting-errors</a></li>
<li><a href="https://dave.cheney.net/2016/04/07/constant-errors" target="_blank" rel="noopener">https://dave.cheney.net/2016/04/07/constant-errors</a></li>
</ul>
<p>相反，我想谈关于错误处理的其它两个方面。</p>
<h2 id="通过消除错误来消除错误处理"><a href="#通过消除错误来消除错误处理" class="headerlink" title="通过消除错误来消除错误处理"></a>通过消除错误来消除错误处理</h2><p>您昨天可能听了我的讲演，我谈到了关于改进错误处理的建议草案。但是您知道有什么是比改进错误处理语法更好的吗？那就是根本不用处理错误。</p>
<blockquote>
<p>注意：我并不是说“移除您的错误处理”。我建议的是，修改您的代码，从而无需处理错误。</p>
</blockquote>
<p>本节是从 John Ousterhout 的新书《A philosophy of Software Design》<a href="https://www.amazon.com/Philosophy-Software-Design-John-Ousterhout/dp/1732102201" target="_blank" rel="noopener">^9</a>中得到的启示。其中一章是“Define Errors Out of Existence”，我们来把这个建议放到 Go 中来看看。</p>
<h3 id="统计行数"><a href="#统计行数" class="headerlink" title="统计行数"></a>统计行数</h3><p>让我们来写一个统计文件行数的函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CountLines</span><span class="params">(r io.Reader)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> (</span><br><span class="line">    br    = bufio.NewReader(r)</span><br><span class="line">    lines <span class="keyword">int</span></span><br><span class="line">    err   error</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    _, err = br.ReadString(<span class="string">'\n'</span>)</span><br><span class="line">    lines++</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> err != io.EOF &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>, err</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> lines, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于我们要遵循上一节的建议，<code>CountLines</code>持有了一个 <code>io.Reader</code>，而非 <code>*File</code>——提供要计数内容的 <code>io.Reader</code> 是调用者的职责。</p>
<p>我们构造了一个<code>bufio.Reader</code>，并将它放到循环中调用<code>ReadString</code>方法，累加一个计数器，直到文件末尾，然后我们返回读取到的行数。</p>
<p>至少这是我们期望的的代码，但这个函数因为错误处理变得更加复杂。例如，这里有个奇怪的结构：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_, err = br.ReadString(<span class="string">'\n'</span>)</span><br><span class="line">lines++</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">break</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在判断错误<strong>之前</strong>累加了计数——这看起来很怪异。</p>
<p>我之所以写成这样，是因为<code>ReadString</code>在遇到换行符之前如果遇到文件结尾则会返回一个错误，如果文件中没有最终换行符，则会发生这种情况。</p>
<p>为了修复这个问题，我们重新排列逻辑以累加行数，然后查看是否需要退出循环。</p>
<blockquote>
<p>注意：这个逻辑依然不够完美，您能发现 bug 吗？</p>
</blockquote>
<p>错误还没有检查完毕。<code>ReadString</code>在遇到文件末尾时会返回<code>io.EOF</code>。这是符合预期的，<code>ReadString</code>需要某种方式“叫停，后面没有更多的东西可读取了”。因此在我们向<code>CountLine</code>的调用者返回错误之前，我们需要检查错误<strong>不是</strong><code>io.EOF</code>，并且在这种情况下才将其进行传播，否则我们返回 <code>nil</code> 说一切正常。</p>
<p>Russ Cox 觉察到错误处理可能会模 ​​ 糊函数操作，我想这就是个很好的例子。让我们来看一个优化的版本：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CountLines</span><span class="params">(r io.Reader)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">  sc := bufio.NewScanner(r)</span><br><span class="line">  lines := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> sc.Scan() &#123;</span><br><span class="line">    lines++</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> lines, sc.Err()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个优化的版本选择使用 <code>bufio.Scanner</code> 而不是 <code>bufio.Reader</code>。</p>
<p>在 <code>bufio.Scanner</code> 的封装下使用 <code>bufio.Reader</code>，但它提供了一个很好的抽象层，帮助我们移除了 <code>CountLines</code> 操作模糊不清的错误。</p>
<blockquote>
<p>注意：<code>bufio.Scanner</code> 可以根据任何模式扫描，但默认只查找换行。</p>
</blockquote>
<p><code>sc.Scan()</code> 这个方法，在匹配到一行文本并且没有遇到错误时会返回 <code>true</code>，因此，<code>for</code> 循环会在遇到文件结尾或者遇到错误时退出。类型 <code>bufio.Scanner</code> 会记录它遇到的第一个错误，一旦退出，我们可以使用 <code>sc.Err()</code> 方法获取到这个错误。</p>
<p>最后，<code>sc.Err()</code> 会合理处理 <code>io.EOF</code>，并且在遇到文件结尾但没有其他错误时，将错误转化为 <code>nil</code>。</p>
<blockquote>
<p>小窍门：当您发现自己遇到难以消除的错误时，请尝试将某些操作提取到帮助类中。</p>
</blockquote>
<h3 id="写入响应"><a href="#写入响应" class="headerlink" title="写入响应"></a>写入响应</h3><p>我的第二个例子受到了博客文章“Errors are values”<a href="https://blog.golang.org/errors-are-values" target="_blank" rel="noopener">^10</a>的启发。</p>
<p>之前的讲演中我们已经看过如何打开、写入和关闭文件。错误处理还存在，但不是那么难以消除，我们可以使用 <code>ioutil.ReadFile</code> 和 <code>ioutil.WriteFile</code> 来封装。但是当我们处理低级别的网络协议时，有必要通过 I/O 来构建响应，这就让错误处理可能变得重复。考虑构建 HTTP 响应的 HTTP 服务器的这个片段：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Header <span class="keyword">struct</span> &#123;</span><br><span class="line">  Key, Value <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Status <span class="keyword">struct</span> &#123;</span><br><span class="line">  Code   <span class="keyword">int</span></span><br><span class="line">  Reason <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteResponse</span><span class="params">(w io.Writer, st Status, headers []Header, body io.Reader)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  _, err := fmt.Fprintf(w, <span class="string">"HTTP/1.1 %d %s\r\n"</span>, st.Code, st.Reason)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> _, h := <span class="keyword">range</span> headers &#123;</span><br><span class="line">    _, err := fmt.Fprintf(w, <span class="string">"%s: %s\r\n"</span>, h.Key, h.Value)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> _, err := fmt.Fprint(w, <span class="string">"\r\n"</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _, err = io.Copy(w, body)</span><br><span class="line">  <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们使用 <code>fmt.Fprintf</code> 构造了状态行并且检查了错误。然后为每个请求头写入键和值，同样检查了错误。最后我们使用 <code>\r\n</code> 终结了请求头这一段，仍然检查了错误。接下来复制响应体到客户端。最后，尽管我们不用检查 <code>io.Copy</code> 的错误，但我们也需要将 <code>io.Copy</code> 的双返回值转换为 <code>WriteResponse</code> 所需的单返回值。</p>
<p>这有太多的重复工作了。我们可以通过引入一个小的封装类 <code>errWriter</code> 来让这件事变得更容易。</p>
<p><code>errWriter</code> 满足 <code>io.Writer</code> 的契约，因此它可以用来包装现有的 <code>io.Writer</code>。<code>errWriter</code> 将写入传递给底层的 Writer，直到检测到错误，从这开始，它会丢弃任何写入并返回先前的错误。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> errWriter <span class="keyword">struct</span> &#123;</span><br><span class="line">  io.Writer</span><br><span class="line">  err error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *errWriter)</span> <span class="title">Write</span><span class="params">(buf []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> e.err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>, e.err</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> n <span class="keyword">int</span></span><br><span class="line">  n, e.err = e.Writer.Write(buf)</span><br><span class="line">  <span class="keyword">return</span> n, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteResponse</span><span class="params">(w io.Writer, st Status, headers []Header, body io.Reader)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  ew := &amp;errWriter&#123;Writer: w&#125;</span><br><span class="line">  fmt.Fprintf(ew, <span class="string">"HTTP/1.1 %d %s\r\n"</span>, st.Code, st.Reason)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> _, h := <span class="keyword">range</span> headers &#123;</span><br><span class="line">    fmt.Fprintf(ew, <span class="string">"%s: %s\r\n"</span>, h.Key, h.Value)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fmt.Fprint(ew, <span class="string">"\r\n"</span>)</span><br><span class="line">  io.Copy(ew, body)</span><br><span class="line">  <span class="keyword">return</span> ew.err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 <code>errWriter</code> 替换 <code>WriteResponse</code> 可以显着提高代码的清晰度。每个操作不再需要用错误检查来自我修复。通过检查 <code>ew.err</code> 字段来将报告错误移动到函数的末尾，同时也避免因为 io.Copy 的多返回值而引起恼人的转换。</p>
<h2 id="错误只处理一次"><a href="#错误只处理一次" class="headerlink" title="错误只处理一次"></a>错误只处理一次</h2><p>最后，我想提一下您应该<strong>只处理一次</strong>错误。处理错误意味着检查错误值并做出<strong>单一</strong>决定。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WriteAll writes the contents of buf to the supplied writer.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteAll</span><span class="params">(w io.Writer, buf []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line">  w.Write(buf)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果错误您一次都不处理，那您就忽略了它。就像我们看到的这样，<code>w.WriteAll</code> 的错误完全被丢弃了。</p>
<p>但是对单一错误做出多次处理决定，也是有问题的。以下是我经常遇到的代码。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteAll</span><span class="params">(w io.Writer, buf []<span class="keyword">byte</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  _, err := w.Write(buf)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Println(<span class="string">"unable to write:"</span>, err) <span class="comment">// annotated error goes to log file</span></span><br><span class="line">    <span class="keyword">return</span> err                           <span class="comment">// unannotated error returned to caller</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，如果 <code>w.Write</code> 产生了一个错误，则会在日志文件中写一行日志，记录错误发生的文件和代码行，并且错误又同时被返回给了调用者，调用者又可能去记录日志，继续返回，直至回溯到程序的顶部。</p>
<p>调用者可能也会做同样的事，</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteConfig</span><span class="params">(w io.Writer, conf *Config)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  buf, err := json.Marshal(conf)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Printf(<span class="string">"could not marshal config: %v"</span>, err)</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> err := WriteAll(w, buf); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Println(<span class="string">"could not write config: %v"</span>, err)</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到头来在您的日志中会出现重复的行，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unable to write: io.EOF</span><br><span class="line">could not write config: io.EOF</span><br></pre></td></tr></table></figure>
<p>但在程序的顶部，您得到了一个没有上下文的原始错误，</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">err := WriteConfig(f, &amp;conf)</span><br><span class="line">fmt.Println(err) <span class="comment">// io.EOF</span></span><br></pre></td></tr></table></figure>
<p>我想进一步深入研究这一点，因为我不认为记录<strong>并且</strong>返回错误仅仅是个人偏好的问题。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteConfig</span><span class="params">(w io.Writer, conf *Config)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  buf, err := json.Marshal(conf)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Printf(<span class="string">"could not marshal config: %v"</span>, err)</span><br><span class="line">    <span class="comment">// oops, forgot to return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> err := WriteAll(w, buf); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Println(<span class="string">"could not write config: %v"</span>, err)</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我看到的很多问题是程序员忘记在错误处返回。正如我们之前谈到的那样，Go 风格应当使用保护条款，检查函数进行下去的前提条件，并提前返回。</p>
<p>在这个示例中，作者处理了错误，记录了日志，但忘记返回，这将导致一个难以觉察的 bug。</p>
<p>在 Go 的错误处理契约中，如果出现错误，您不能对其他返回值的内容做出任何假设。就像上例中如果 JSON 反序列化失败，<code>buf</code> 的内容未知，可能什么都不包含，但包含了 1/2 的 JSON 片段会更糟糕。</p>
<p>因为程序员在检查和日志记录了错误之后忘记返回，一个混乱的缓冲区被传递给了 <code>WriteAll</code>，它又可能执行成功，这样配置文件就会被错误地覆盖了。但此时函数会正常返回，并且发生问题的唯一迹象只是单个日志行记录了 JSON 编码失败，而不是编写配置文件失败。</p>
<h3 id="向错误添加上下文"><a href="#向错误添加上下文" class="headerlink" title="向错误添加上下文"></a>向错误添加上下文</h3><p>这个 bug 的发生是因为作者尝试向错误消息添加<strong>上下文</strong>信息。他们试图给自己留下一个线索，指引他们回到错误的源头。</p>
<p>让我们看看使用 <code>fmt.Errorf</code> 来做同样的事的另一种方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteConfig</span><span class="params">(w io.Writer, conf *Config)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  buf, err := json.Marshal(conf)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Errorf(<span class="string">"could not marshal config: %v"</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> err := WriteAll(w, buf); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Errorf(<span class="string">"could not write config: %v"</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteAll</span><span class="params">(w io.Writer, buf []<span class="keyword">byte</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  _, err := w.Write(buf)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Errorf(<span class="string">"write failed: %v"</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过将错误的注释与返回组合到一行，则以就更难以忘记返回错误，从而避免意外继续。</p>
<p>如果写文件时发生一个 I/O 错误，错误对象的 <code>Error()</code> 方法将会报告如下信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">could not write config: write failed: input/output error</span><br></pre></td></tr></table></figure>
<h3 id="使用-github-com-pkg-errors-包装错误"><a href="#使用-github-com-pkg-errors-包装错误" class="headerlink" title="使用 github.com/pkg/errors 包装错误"></a>使用 <code>github.com/pkg/errors</code> 包装错误</h3><p><code>fmt.Errorf</code> 模式适用于提示错误信息，但其代价是原始的错误类型被掩盖了。我认为，将错误视为不透明的值对于生成松散耦合的软件很重要，所以如果对错误值所做的唯一事情是如下两个方面的话，则原始错误是什么类型就无关紧要了。</p>
<ol>
<li>检查是否为 <code>nil</code></li>
<li>打印或记录日志</li>
</ol>
<p>但是，在某些场景，可能并不常见，您确实需要恢复原始错误。在这种情况下，您可以使用类似我的 <code>errors</code> 包来备注这样的错误。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadFile</span><span class="params">(path <span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">  f, err := os.Open(path)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrap(err, <span class="string">"open failed"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">defer</span> f.Close()</span><br><span class="line"></span><br><span class="line">  buf, err := ioutil.ReadAll(f)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrap(err, <span class="string">"read failed"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> buf, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadConfig</span><span class="params">()</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">  home := os.Getenv(<span class="string">"HOME"</span>)</span><br><span class="line">  config, err := ReadFile(filepath.Join(home, <span class="string">".settings.xml"</span>))</span><br><span class="line">  <span class="keyword">return</span> config, errors.WithMessage(err, <span class="string">"could not read config"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  _, err := ReadConfig()</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">    os.Exit(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在报告的错误将会是很好的 K&amp;D <a href="http://www.gopl.io/" target="_blank" rel="noopener">^11</a> 风格的错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">could not read config: open failed: open /Users/dfc/.settings.xml: no such file or directory</span><br></pre></td></tr></table></figure>
<p>并且错误值保留了对原始原因的引用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  _, err := ReadConfig()</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"original error: %T %v\n"</span>, errors.Cause(err), errors.Cause(err))</span><br><span class="line">    fmt.Printf(<span class="string">"stack trace:\n%+v\n"</span>, err)</span><br><span class="line">    os.Exit(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从而您可以恢复原始的错误，并且打印其堆栈：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">original error: *os.PathError open /Users/dfc/.settings.xml: no such file or directory</span><br><span class="line">stack trace:</span><br><span class="line">open /Users/dfc/.settings.xml: no such file or directory</span><br><span class="line">open failed</span><br><span class="line">main.ReadFile</span><br><span class="line">        /Users/dfc/devel/practical-go/src/errors/readfile2.go:16</span><br><span class="line">main.ReadConfig</span><br><span class="line">        /Users/dfc/devel/practical-go/src/errors/readfile2.go:29</span><br><span class="line">main.main</span><br><span class="line">        /Users/dfc/devel/practical-go/src/errors/readfile2.go:35</span><br><span class="line">runtime.main</span><br><span class="line">        /Users/dfc/go/src/runtime/proc.go:201</span><br><span class="line">runtime.goexit</span><br><span class="line">        /Users/dfc/go/src/runtime/asm_amd64.s:1333</span><br><span class="line">could not read config</span><br></pre></td></tr></table></figure>
<p>使用 <code>errors</code> 包让您得可以以人和机器都能检测到的方式向错误添加上下文。如果您昨天来看了我的讲演，就会知道 <code>error</code> 的包装正在进入即将发布的 Go 版本的标准库。</p>
<h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><p>我们选择 Go 开发项目通常是因为其并发的特性。Go 团队已经竭尽全力使 Go 中的并发性廉价（在硬件资源方面）并具有高性能，但是使用 Go 的并发性写出既不高性能也不可靠的代码仍然是可能的。在我即将离开的时候，我想留下一些关于避免并发特性带来的陷阱的建议。</p>
<p>Go 特性支持的第一类并发是针对通道、<code>select</code> 语句和 <code>go</code> 语句的。如果你从书籍或者培训课程中正式地学习过，你可能注意到并发这一节总是在最后才会讲到。这里也不例外，我选择最后才讲并发，好像它是对于 Go 程序员来说应该掌握的常规技能之外的附加部分。</p>
<p>这有两个方面。一方面 Go 的主旨是简单、轻量的并发模型。作为一个产品，我们的语言几乎只靠这方面进行兜售。另一方面，有一种说法认为并发实际上并不容易使用，否则作者并不会放到一本书的最后一章，我们回首我们之前的努力时也不会带有遗憾。</p>
<p>本节讨论使用 Go 原生的并发特性时的一些陷阱。</p>
<h2 id="保持自己忙碌，否则自己做"><a href="#保持自己忙碌，否则自己做" class="headerlink" title="保持自己忙碌，否则自己做"></a>保持自己忙碌，否则自己做</h2><p>这段程序有什么问题？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"log"</span></span><br><span class="line">  <span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  http.HandleFunc(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    fmt.Fprintln(w, <span class="string">"Hello, GopherCon SG"</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err := http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码按我们预期在执行，他开启了一个简单的 Web 服务。但它同时又干了些别的事情，那就是在一个无限循环中浪费 CPU。这是因为<code>main</code>的最后一行<code>for {}</code>循环阻塞了主的协程，因为它不做任何输入输出，也不等待锁，也不在通道上做发送或接收，或以其他方式与调度程序通信。</p>
<p>由于 Go 运行时主要是协同安排的，因此该程序将在单个 CPU 上无效地循环，并且可能最终被实时锁定。</p>
<p>我们要怎么修复它呢？这里有个建议：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"log"</span></span><br><span class="line">  <span class="string">"net/http"</span></span><br><span class="line">  <span class="string">"runtime"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  http.HandleFunc(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    fmt.Fprintln(w, <span class="string">"Hello, GopherCon SG"</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err := http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    runtime.Gosched()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这可能看起来很愚蠢，但这是我看到的最通常的解决方案。这是不了解根本问题的症结所在。</p>
<p>现在，如果你对 Go 稍有经验，你可能写成这样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"log"</span></span><br><span class="line">  <span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  http.HandleFunc(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    fmt.Fprintln(w, <span class="string">"Hello, GopherCon SG"</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err := http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">select</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>任何一个空的 <code>select</code> 语句都会永远阻塞在那。这是个很有用的性质，因为现在我们不想仅仅因为调用<code>runtime.GoSched()</code>就让整个 CPU 都“旋转”起来。但这样做，我们只治了标，没有治本。</p>
<p>我想向你提出另一种解决方案，希望这一方案已经被采用了。与其让<code>http.ListenAndServe</code>在一个协程中执行并带来一个“主协程中应该做什么”的问题，不如简单地由主协程自己来执行<code>http.ListenAndServe</code>。</p>
<blockquote>
<p>小窍门：Go 程序的 <code>main.mian</code> 函数退出，则 Go 程序都会无条件退出，不论其他协程正在做什么。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"log"</span></span><br><span class="line">  <span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  http.HandleFunc(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    fmt.Fprintln(w, <span class="string">"Hello, GopherCon SG"</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">if</span> err := http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总之，这是我的第一个简易：如果你的协程在其他协程返回结果之前什么事都不能干，通常就应该直接了当地自己做这件事，而不是委托其他协程去做。</p>
<p>这通常也消除了将结果从协程引导回其发起者所需的大量状态跟踪和通道操作。</p>
<blockquote>
<p>小窍门：许多 Go 程序员滥用协程，特别是初学者。与生活中的所有事情一样，适度是成功的关键。</p>
</blockquote>
<h2 id="将并发留给调用者"><a href="#将并发留给调用者" class="headerlink" title="将并发留给调用者"></a>将并发留给调用者</h2><p>下面两个 API 的区别是什么？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ListDirectory returns the contents of dir.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListDirectory</span><span class="params">(dir <span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">string</span>, error)</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ListDirectory returns a channel over which</span></span><br><span class="line"><span class="comment">// directory entries will be published. When the list</span></span><br><span class="line"><span class="comment">// of entries is exhausted, the channel will be closed.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListDirectory</span><span class="params">(dir <span class="keyword">string</span>)</span> <span class="title">chan</span> <span class="title">string</span></span></span><br></pre></td></tr></table></figure>
<p>首先，显著的区别是，第一个例子读取目录到切片，然后将整个切片返回，否则如果有问题则返回一个错误。这是同步发生的，<code>ListDirectory</code>的调用者将被阻塞直到整个目录被读完。依赖于目录有多大，这个过程可能持续很长时间，也可能因为构建一个目录条目名称的切片，而分配大量的内存。</p>
<p>让我们来看看第二个例子。这更一个更像 Go，<code>ListDirectory</code>返回了一个传输目录条目的通道，当通道关闭时，表明没有更多目录条目了。由于通道信息发生在<code>ListDirectory</code>返回之后，<code>ListDirectory</code>内部可能开启了一个协程。</p>
<blockquote>
<p>注意：第二个版本实际上没有必要真的使用一个协程。它可以分配一个足以保存所有目录条目而不阻塞的通道，填充通道，关闭它，然后将通道返回给调用者。但这不太可能，因为这会消耗大量内存来缓冲通道中的所有结果。</p>
</blockquote>
<p>通道版本的<code>ListDirectory</code>还有两个进一步的问题：</p>
<ul>
<li>通过使用通道的关闭作为没有更多项目要处理的信号，<code>ListDirectory</code>在中途遇到错误就无法告知调用者返回的集合是不完整的。调用者也无法区分空目录和一读取就产生错误的情况，这两种结果对于<code>ListDirectory</code>返回的通道来说都是立即关闭。</li>
<li>调用者<strong>必须</strong>持续读取通道的内容直到通道关闭，因为这是让调用者知道协程已经结束的唯一办法。这是对<code>ListDirectory</code>的使用的一个严重限制。调用者必须花时间从通道读取数据，哪怕调用者已经接收到它想要的信息。就需要使用大量内存的中型到大型目录而言，它可能更有效，但这种方法并不比原始的基于切片的方法快。</li>
</ul>
<p>以上两个实现中的问题，其解决方案是使用回调。一个在每个目录条目上执行的函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListDirectory</span><span class="params">(dir <span class="keyword">string</span>, fn <span class="keyword">func</span>(<span class="keyword">string</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<p>毫不奇怪，<code>filepath.WalkDir</code>就是这么做的。</p>
<blockquote>
<p>小窍门：如果你的函数开启了一个协程，那么你必须给调用者提供一个停止协程的途径。将异步执行函数的决策留给该函数的调用者通常更容易。</p>
</blockquote>
<h2 id="不要启动一个永不停止的协程"><a href="#不要启动一个永不停止的协程" class="headerlink" title="不要启动一个永不停止的协程"></a>不要启动一个永不停止的协程</h2><p>上一个例子演示了没有必要的情况下使用协程。但使用 Go 的驱动原因之一是该语言提供的第一类并发功能。实际上，在许多情况下，您希望利用硬件中可用的并行性。为此，你必须使用协程。</p>
<p>这个简单的应用，在两个不同的端口上提供 http 服务，端口 8080 用于应用本身的流量，8081 用于访问 <code>/debug/pprof</code> 终结点。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"net/http"</span></span><br><span class="line">  _ <span class="string">"net/http/pprof"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  mux := http.NewServeMux()</span><br><span class="line">  mux.HandleFunc(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(resp http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">    fmt.Fprintln(resp, <span class="string">"Hello, QCon!"</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">go</span> http.ListenAndServe(<span class="string">"127.0.0.1:8001"</span>, http.DefaultServeMux) <span class="comment">// debug</span></span><br><span class="line">  http.ListenAndServe(<span class="string">"0.0.0.0:8080"</span>, mux)                       <span class="comment">// app traffic</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尽管这个程序不是很复杂，但它代表了一个基本的真实应用程序。</p>
<p>随着应用程序的增长，有一些问题也显现出来，让我们现在来解决其中的一些。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">serveApp</span><span class="params">()</span></span> &#123;</span><br><span class="line">  mux := http.NewServeMux()</span><br><span class="line">  mux.HandleFunc(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(resp http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">    fmt.Fprintln(resp, <span class="string">"Hello, QCon!"</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  http.ListenAndServe(<span class="string">"0.0.0.0:8080"</span>, mux)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">serveDebug</span><span class="params">()</span></span> &#123;</span><br><span class="line">  http.ListenAndServe(<span class="string">"127.0.0.1:8001"</span>, http.DefaultServeMux)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">go</span> serveDebug()</span><br><span class="line">  serveApp()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过将 <code>serveApp</code> 和 <code>serveDebug</code> 的功能放到到各自的函数中，我们把他们从 main.main 分离出来。我们照样遵循了上面的建议，把 <code>serveApp</code> 和 <code>serveDebug</code> 的并发性留给了调用者。</p>
<p>但是这个程序有一些可操作性上的问题。如果<code>serveApp</code>返回则<code>main.main</code>会返回并导致程序关闭，最终由您正在使用的任何进程管理器重新启动。</p>
<blockquote>
<p>小窍门：正如函数的并发性留给调用者一样，应用应该将状态监视、重启留给程序的唤起者。不要让你的应用程序担负重启自身的责任，这是一个最好从应用程序外部处理的过程。</p>
</blockquote>
<p>但是，<code>serveDebug</code> 是在另一个协程中执行的，如果它退出，也仅仅是这个协程自身退出，程序的其他部分将继续运行。由于<code>/debug</code>处理程序停止工作，您的操作人员会很不高兴地发现他们无法在应用程序中获取统计信息。</p>
<p>我们要确保的是，负责服务此应用程序的任何协程停止，都关闭应用程序。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">serveApp</span><span class="params">()</span></span> &#123;</span><br><span class="line">  mux := http.NewServeMux()</span><br><span class="line">  mux.HandleFunc(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(resp http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">    fmt.Fprintln(resp, <span class="string">"Hello, QCon!"</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">if</span> err := http.ListenAndServe(<span class="string">"0.0.0.0:8080"</span>, mux); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">serveDebug</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> err := http.ListenAndServe(<span class="string">"127.0.0.1:8001"</span>, http.DefaultServeMux); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">go</span> serveDebug()</span><br><span class="line">  <span class="keyword">go</span> serveApp()</span><br><span class="line">  <span class="keyword">select</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们通过必要时调用 <code>log.Fatal</code> 来检查 <code>serverApp</code> 和 <code>serveDebug</code> 从 <code>ListenAndServe</code> 返回的错误。由于两个处理器都是在协程中运行，我们使用 <code>select{}</code> 来阻塞主协程。</p>
<p>这种方法存在许多问题：</p>
<ol>
<li>如果 <code>ListenAndServe</code> 返回一个 <code>nil</code>，<code>log.Fatal</code>不会被调用，则对应的 HTTP 服务会停止，并且应用程序不会退出。</li>
<li><code>log.Fatal</code> 会调用 <code>os.Exit</code> 无条件终止进程，defer 不会被调用，其他协程不会被通知关闭，应用程序会停止。这会使得为这些函数编写测试用例变得很困难。</li>
</ol>
<blockquote>
<p>小窍门：只在 <code>main.main</code> 或 <code>init</code> 函数里使用 <code>log.Fatal</code>。</p>
</blockquote>
<p>我们需要的是，把任何错误都传回协程的发起者，以便于我们弄清楚为什么协程会停止，并且可以干净地关闭进程。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">serveApp</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  mux := http.NewServeMux()</span><br><span class="line">  mux.HandleFunc(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(resp http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">    fmt.Fprintln(resp, <span class="string">"Hello, QCon!"</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> http.ListenAndServe(<span class="string">"0.0.0.0:8080"</span>, mux)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">serveDebug</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> http.ListenAndServe(<span class="string">"127.0.0.1:8001"</span>, http.DefaultServeMux)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  done := <span class="built_in">make</span>(<span class="keyword">chan</span> error, <span class="number">2</span>)</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    done &lt;- serveDebug()</span><br><span class="line">  &#125;()</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    done &lt;- serveApp()</span><br><span class="line">  &#125;()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">cap</span>(done); i++ &#123;</span><br><span class="line">    <span class="keyword">if</span> err := &lt;-done; err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">"error: %v"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以使用一个通道来收集协程返回的状态。通道的大小与我们要管理的协程数一致，从而使得向 <code>done</code> 通道发送状态时不会被阻塞，否则这将阻塞协程的关闭，导致泄漏。</p>
<p>由于没有办法安全地关闭 <code>done</code> 通道，我们不能使用 <code>for range</code> 循环通道知道所有协程都上报了信息，因此我们循环开启协程的次数，这也等于通道的容量。</p>
<p>现在我们有办法等待协程干净地退出，并且记录发生的日志。我们所需的仅仅是将一个协程的关闭信号，通知到其他协程而已。</p>
<p>其结果是，通知一个 <code>http.Server</code> 关闭这事被引入进来。所以我将这个逻辑转换为辅助函数。<code>serve</code> 帮助我们持有一个地址和一个 <code>http.Handler</code>，类似 <code>http.ListenAndServe</code> 以及一个用于触发 <code>Shutdown</code> 方法的 <code>stop</code> 通道。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">serve</span><span class="params">(addr <span class="keyword">string</span>, handler http.Handler, stop &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  s := http.Server&#123;</span><br><span class="line">    Addr:    addr,</span><br><span class="line">    Handler: handler,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    &lt;-stop <span class="comment">// wait for stop signal</span></span><br><span class="line">    s.Shutdown(context.Background())</span><br><span class="line">  &#125;()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> s.ListenAndServe()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">serveApp</span><span class="params">(stop &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  mux := http.NewServeMux()</span><br><span class="line">  mux.HandleFunc(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(resp http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">    fmt.Fprintln(resp, <span class="string">"Hello, QCon!"</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> serve(<span class="string">"0.0.0.0:8080"</span>, mux, stop)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">serveDebug</span><span class="params">(stop &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> serve(<span class="string">"127.0.0.1:8001"</span>, http.DefaultServeMux, stop)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  done := <span class="built_in">make</span>(<span class="keyword">chan</span> error, <span class="number">2</span>)</span><br><span class="line">  stop := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    done &lt;- serveDebug(stop)</span><br><span class="line">  &#125;()</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    done &lt;- serveApp(stop)</span><br><span class="line">  &#125;()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> stopped <span class="keyword">bool</span></span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">cap</span>(done); i++ &#123;</span><br><span class="line">    <span class="keyword">if</span> err := &lt;-done; err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">"error: %v"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !stopped &#123;</span><br><span class="line">      stopped = <span class="literal">true</span></span><br><span class="line">      <span class="built_in">close</span>(stop)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，每当我们从 <code>done</code> 通道接收到一个值，就关闭 <code>stop</code> 通道，从而导致所有等待在这个通道上的协程关闭 <code>http.Server</code>。这将导致所有剩余的 <code>ListenAndServe</code> 协程返回。一旦我们启动的协程停止，<code>main.main</code> 便返回继而进程干净地停止了。</p>
<blockquote>
<p>小窍门：自己写这个逻辑是重复和微妙的。考虑类似这个包的东西，<a href="https://github.com/heptio/workgroup" target="_blank" rel="noopener">https://github.com/heptio/workgroup</a> 它将为你完成大部分工作。</p>
</blockquote>
<p>【完】</p>
<blockquote>
<p>翻译水平有限，如有偏颇之处，烦请<a href="http://shang.qq.com/wpa/qunwpa?idkey=2aa3ef00102d1db4f2275d835aabf3eb043e8ba7b22ead791ba469cdb198a8cc" target="_blank" rel="noopener">联系我</a>更正。转载请注明出处。翻译：Austin Luo；邮箱：<a href="mailto:uonun@163.com" target="_blank" rel="noopener">uonun@163.com</a></p>
</blockquote>

      
    </div>

    
      


    

    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Go/" rel="tag"># Go</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/10/08/在-Visual-Studio-Code-中使用-MINGW32-作为终端/" rel="next" title="在 Visual Studio Code 中使用 MINGW32 作为终端">
                <i class="fa fa-chevron-left"></i> 在 Visual Studio Code 中使用 MINGW32 作为终端
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/01/23/Using-portable-commands-like-zip-tar-on-Windows/" rel="prev" title="Using portable commands like zip/tar on Windows">
                Using portable commands like zip/tar on Windows <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="https://avatars3.githubusercontent.com/u/934574?s=400&u=e82170d672ed95a22dfe72374fde752cf973b785&v=4"
                alt="Austin Luo" />
            
              <p class="site-author-name" itemprop="name">Austin Luo</p>
              <p class="site-description motion-element" itemprop="description">架构师，腾讯<br />专注微服务和软件基础设施建设</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">12</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">17</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/uonun" target="_blank" title="GitHub" rel="external nofollow"><i class="fa fa-fw fa-github"></i>GitHub</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://bitbucket.org/uonun/" target="_blank" title="Bitbucket" rel="external nofollow"><i class="fa fa-fw fa-bitbucket"></i>Bitbucket</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="//shang.qq.com/wpa/qunwpa?idkey=2aa3ef00102d1db4f2275d835aabf3eb043e8ba7b22ead791ba469cdb198a8cc" target="_blank" title="QQ 群" rel="external nofollow"><i class="fa fa-fw fa-qq"></i>QQ 群</a>
                  
                </span>
              
            </div>
          

          
          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#指导原则"><span class="nav-number">1.</span> <span class="nav-text">指导原则</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#简单性"><span class="nav-number">1.1.</span> <span class="nav-text">简单性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#可读性"><span class="nav-number">1.2.</span> <span class="nav-text">可读性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#生产率"><span class="nav-number">1.3.</span> <span class="nav-text">生产率</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#标识符"><span class="nav-number">2.</span> <span class="nav-text">标识符</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#选择清晰的名称，而不是简洁的名称"><span class="nav-number">2.1.</span> <span class="nav-text">选择清晰的名称，而不是简洁的名称</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#标识符长度"><span class="nav-number">2.2.</span> <span class="nav-text">标识符长度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#上下文是关键"><span class="nav-number">2.2.1.</span> <span class="nav-text">上下文是关键</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#命名中不要包含所属类型的名称"><span class="nav-number">2.3.</span> <span class="nav-text">命名中不要包含所属类型的名称</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用一致的命名风格"><span class="nav-number">2.4.</span> <span class="nav-text">使用一致的命名风格</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用一致的声明风格"><span class="nav-number">2.5.</span> <span class="nav-text">使用一致的声明风格</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#成为团队合作者"><span class="nav-number">2.6.</span> <span class="nav-text">成为团队合作者</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#代码注释"><span class="nav-number">3.</span> <span class="nav-text">代码注释</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#变量和常量上的注释应当描述它的内容，而非目的"><span class="nav-number">3.1.</span> <span class="nav-text">变量和常量上的注释应当描述它的内容，而非目的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总是为公开符号写文档说明"><span class="nav-number">3.2.</span> <span class="nav-text">总是为公开符号写文档说明</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#不要为坏的代码写注释，重写它"><span class="nav-number">3.2.1.</span> <span class="nav-text">不要为坏的代码写注释，重写它</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#与其为一大段代码写注释，不如重构它"><span class="nav-number">3.2.2.</span> <span class="nav-text">与其为一大段代码写注释，不如重构它</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#包的设计"><span class="nav-number">4.</span> <span class="nav-text">包的设计</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#一个好的包从它的名称开始"><span class="nav-number">4.1.</span> <span class="nav-text">一个好的包从它的名称开始</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#好的包名应该是唯一的"><span class="nav-number">4.1.1.</span> <span class="nav-text">好的包名应该是唯一的</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#避免将包命名为base、common、util"><span class="nav-number">4.2.</span> <span class="nav-text">避免将包命名为base、common、util</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#快速返回，而不是深层嵌套"><span class="nav-number">4.3.</span> <span class="nav-text">快速返回，而不是深层嵌套</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#让零值变得有意义"><span class="nav-number">4.4.</span> <span class="nav-text">让零值变得有意义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#避免包级别的状态"><span class="nav-number">4.5.</span> <span class="nav-text">避免包级别的状态</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#项目结构"><span class="nav-number">5.</span> <span class="nav-text">项目结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#考虑更少、更大的包"><span class="nav-number">5.1.</span> <span class="nav-text">考虑更少、更大的包</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#通过-import-语句将代码整理到多个文件中"><span class="nav-number">5.1.1.</span> <span class="nav-text">通过 import 语句将代码整理到多个文件中</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内部测试优于外部测试"><span class="nav-number">5.1.2.</span> <span class="nav-text">内部测试优于外部测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用-internal-包收敛公开的-API-表面"><span class="nav-number">5.1.3.</span> <span class="nav-text">使用 internal 包收敛公开的 API 表面</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#确保-main-包越小越好"><span class="nav-number">5.2.</span> <span class="nav-text">确保 main 包越小越好</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#API-设计"><span class="nav-number">6.</span> <span class="nav-text">API 设计</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#设计难以被误用的-API"><span class="nav-number">6.1.</span> <span class="nav-text">设计难以被误用的 API</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#警惕具有多个相同类型参数的函数"><span class="nav-number">6.1.1.</span> <span class="nav-text">警惕具有多个相同类型参数的函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#针对默认用例设计-API"><span class="nav-number">6.2.</span> <span class="nav-text">针对默认用例设计 API</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#不鼓励使用-nil-作为参数"><span class="nav-number">6.2.1.</span> <span class="nav-text">不鼓励使用 nil 作为参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#首选可变参数（var-args）而非切片参数（-T）"><span class="nav-number">6.2.2.</span> <span class="nav-text">首选可变参数（var args）而非切片参数（[]T）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#让函数自身定义它所需的行为"><span class="nav-number">6.3.</span> <span class="nav-text">让函数自身定义它所需的行为</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#错误处理"><span class="nav-number">7.</span> <span class="nav-text">错误处理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#通过消除错误来消除错误处理"><span class="nav-number">7.1.</span> <span class="nav-text">通过消除错误来消除错误处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#统计行数"><span class="nav-number">7.1.1.</span> <span class="nav-text">统计行数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#写入响应"><span class="nav-number">7.1.2.</span> <span class="nav-text">写入响应</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#错误只处理一次"><span class="nav-number">7.2.</span> <span class="nav-text">错误只处理一次</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#向错误添加上下文"><span class="nav-number">7.2.1.</span> <span class="nav-text">向错误添加上下文</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用-github-com-pkg-errors-包装错误"><span class="nav-number">7.2.2.</span> <span class="nav-text">使用 github.com/pkg/errors 包装错误</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#并发"><span class="nav-number">8.</span> <span class="nav-text">并发</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#保持自己忙碌，否则自己做"><span class="nav-number">8.1.</span> <span class="nav-text">保持自己忙碌，否则自己做</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#将并发留给调用者"><span class="nav-number">8.2.</span> <span class="nav-text">将并发留给调用者</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#不要启动一个永不停止的协程"><span class="nav-number">8.3.</span> <span class="nav-text">不要启动一个永不停止的协程</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div id="bottom"></div>
      <div class="footer-inner">
        <div class="copyright">&copy; 2015 – <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-cloud"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">udnz.com</span>

  

  
</div>


  









  <div class="footer-custom"> - 思考 / 一丝不苟 / 精益求精 / 永不满足 / 怀疑一切 / 认知未来 - </div>


        





  <script type="text/javascript">
    (function() {
      var hm = document.createElement("script");
      hm.src = "//tajs.qq.com/stats?sId=16184686";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




        
      </div>
    </footer>    

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.4.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.4.2"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.4.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.4.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.4.2"></script>



  



  










  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  
  

  

  

  

  

  
  <style>
    .copy-btn {
      display: inline-block;
      padding: 6px 12px;
      font-size: 13px;
      font-weight: 700;
      line-height: 20px;
      color: #333;
      white-space: nowrap;
      vertical-align: middle;
      cursor: pointer;
      background-color: #eee;
      background-image: linear-gradient(#fcfcfc, #eee);
      border: 1px solid #d5d5d5;
      border-radius: 3px;
      user-select: none;
      outline: 0;
    }

    .highlight-wrap .copy-btn {
      transition: opacity .3s ease-in-out;
      opacity: 0;
      padding: 2px 6px;
      position: absolute;
      right: 4px;
      top: 8px;
    }

    .highlight-wrap:hover .copy-btn,
    .highlight-wrap .copy-btn:focus {
      opacity: 1
    }

    .highlight-wrap {
      position: relative;
    }
  </style>
  <script>
    $('.highlight').each(function (i, e) {
      var $wrap = $('<div>').addClass('highlight-wrap')
      $(e).after($wrap)
      $wrap.append($('<button>').addClass('copy-btn').append('复制').on('click', function (e) {
        var code = $(this).parent().find('.code').find('.line').map(function (i, e) {
          return $(e).text()
        }).toArray().join('\n')
        var ta = document.createElement('textarea')
        document.body.appendChild(ta)
        ta.style.position = 'absolute'
        ta.style.top = '0px'
        ta.style.left = '0px'
        ta.value = code
        ta.select()
        ta.focus()
        var result = document.execCommand('copy')
        document.body.removeChild(ta)
        
          if(result)$(this).text('复制成功')
          else $(this).text('复制失败')
        
        $(this).blur()
      })).on('mouseleave', function (e) {
        var $b = $(this).find('.copy-btn')
        setTimeout(function () {
          $b.text('复制')
        }, 300)
      }).append(e)
    })
  </script>


</body>
</html>
